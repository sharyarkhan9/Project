[0m[[0m[0mdebug[0m] [0m[0m> Exec(__runWatch console0, Some(43675aa0-efed-4f98-b91b-40af576f380a), Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(sbtStashOnFailure, None, Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(__preWatch console0, None, Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(run, None, Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / run[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@4860627a, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"108","parents":[]},"eventTime":1641484461621,"message":"Compiling project0","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/#project0/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///C:/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"buildTarget":{"uri":"file:/C:/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/#project0/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"108","parents":[]},"eventTime":1641484461629,"message":"Compiled project0","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/#project0/Compile"},"errors":0,"warnings":0,"time":8}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"running Project0 "})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Waiting for threads to exit or System.exit to be called."})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"  Classpath:\n\tC:\\Users\\Family\\Desktop\\Revature - Big Data\\VS Code\\Project0\\target\\bg-jobs\\sbt_2ef7ba9f\\job-10\\target\\890ab113\\5045a77e\\project0-scala_2.11-0.1.jar\n\tC:\\Users\\Family\\Desktop\\Revature - Big Data\\VS Code\\Project0\\target\\bg-jobs\\sbt_2ef7ba9f\\target\\642eee43\\ffcc071c\\scala-library-2.11.12.jar\n\tC:\\Users\\Family\\Desktop\\Revature - Big Data\\VS Code\\Project0\\target\\bg-jobs\\sbt_2ef7ba9f\\target\\fe3bd0a7\\1bf5e67c\\mysql-connector-java-8.0.19.jar\n\tC:\\Users\\Family\\Desktop\\Revature - Big Data\\VS Code\\Project0\\target\\bg-jobs\\sbt_2ef7ba9f\\target\\aae5e2db\\36cca737\\protobuf-java-3.6.1.jar"})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Waiting for thread run-main-9 to terminate."})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":24}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     } [0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     } [0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     } [0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":37}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":85}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol values[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":61,"character":32}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":18})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":61,"character":36}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":19})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":61,"character":41}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol enter[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol only[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Please[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":96}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol arrBuff[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":47}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":22})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":56}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":23})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":62}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":58}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":47}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var query = ("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":26})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":37}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":27})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":29}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":62,"character":29}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":29})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":36}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     for (x <- 0 until arrBuff.length) {[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":30})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     for (x <- 0 until arrBuff.length) {[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":25}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(query)[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Please[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol until[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol println[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/scala-library-2.11.12-sources.jar/scala/Predef.scala","languageId":"scala","version":1,"text":"/*                     __                                               *\\\n**     ________ ___   / /  ___     Scala API                            **\n**    / __/ __// _ | / /  / _ |    (c) 2002-2013, LAMP/EPFL             **\n**  __\\ \\/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **\n** /____/\\___/_/ |_/____/_/ | |                                         **\n**                          |/                                          **\n\\*                                                                      */\n\npackage scala\n\nimport scala.collection.{ mutable, immutable, generic }\nimport immutable.StringOps\nimport mutable.ArrayOps\nimport generic.CanBuildFrom\nimport scala.annotation.{ elidable, implicitNotFound }\nimport scala.annotation.elidable.ASSERTION\nimport scala.language.{implicitConversions, existentials}\nimport scala.io.StdIn\n\n/** The `Predef` object provides definitions that are accessible in all Scala\n *  compilation units without explicit qualification.\n *\n *  === Commonly Used Types ===\n *  Predef provides type aliases for types which are commonly used, such as\n *  the immutable collection types [[scala.collection.immutable.Map]],\n *  [[scala.collection.immutable.Set]], and the [[scala.collection.immutable.List]]\n *  constructors ([[scala.collection.immutable.::]] and\n *  [[scala.collection.immutable.Nil]]).\n *\n *  === Console I/O ===\n *  Predef provides a number of simple functions for console I/O, such as\n *  `print`, `println`, `readLine`, `readInt`, etc. These functions are all\n *  aliases of the functions provided by [[scala.Console]].\n *\n *  === Assertions ===\n *\n *  A set of `assert` functions are provided for use as a way to document\n *  and dynamically check invariants in code. Invocations of `assert` can be elided\n *  at compile time by providing the command line option `-Xdisable-assertions`,\n *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.\n *\n *  Variants of `assert` intended for use with static analysis tools are also\n *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are\n *  intended for use as a means of design-by-contract style specification\n *  of pre- and post-conditions on functions, with the intention that these\n *  specifications could be consumed by a static analysis tool. For instance,\n *\n *  {{{\n *  def addNaturals(nats: List[Int]): Int = {\n *    require(nats forall (_ >= 0), \"List contains negative numbers\")\n *    nats.foldLeft(0)(_ + _)\n *  } ensuring(_ >= 0)\n *  }}}\n *\n *  The declaration of `addNaturals` states that the list of integers passed should\n *  only contain natural numbers (i.e. non-negative), and that the result returned\n *  will also be natural. `require` is distinct from `assert` in that if the\n *  condition fails, then the caller of the function is to blame rather than a\n *  logical error having been made within `addNaturals` itself. `ensuring` is a\n *  form of `assert` that declares the guarantee the function is providing with\n *  regards to its return value.\n *\n *  === Implicit Conversions ===\n *  A number of commonly applied implicit conversions are also defined here, and\n *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions\n *  are provided for the \"widening\" of numeric values, for instance, converting a\n *  Short value to a Long value as required, and to add additional higher-order\n *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].\n */\nobject Predef extends LowPriorityImplicits with DeprecatedPredef {\n  /**\n   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to\n   * the class literal `T.class` in Java.\n   *\n   * @example {{{\n   * val listClass = classOf[List[_]]\n   * // listClass is java.lang.Class[List[_]] = class scala.collection.immutable.List\n   *\n   * val mapIntString = classOf[Map[Int,String]]\n   * // mapIntString is java.lang.Class[Map[Int,String]] = interface scala.collection.immutable.Map\n   * }}}\n   */\n  def classOf[T]: Class[T] = null // This is a stub method. The actual implementation is filled in by the compiler.\n\n  /** The `String` type in Scala has methods that come either from the underlying\n   *  Java String (see the documentation corresponding to your Java version, for\n   *  example [[http://docs.oracle.com/javase/8/docs/api/java/lang/String.html]]) or\n   *  are added implicitly through [[scala.collection.immutable.StringOps]].\n   */\n  type String        = java.lang.String\n  type Class[T]      = java.lang.Class[T]\n\n  // miscellaneous -----------------------------------------------------\n  scala.`package`                         // to force scala package object to be seen.\n  scala.collection.immutable.List         // to force Nil, :: to be seen.\n\n  type Function[-A, +B] = Function1[A, B]\n\n  type Map[A, +B] = immutable.Map[A, B]\n  type Set[A]     = immutable.Set[A]\n  val Map         = immutable.Map\n  val Set         = immutable.Set\n\n  // Manifest types, companions, and incantations for summoning\n  @annotation.implicitNotFound(msg = \"No ClassManifest available for ${T}.\")\n  @deprecated(\"Use `scala.reflect.ClassTag` instead\", \"2.10.0\")\n  type ClassManifest[T] = scala.reflect.ClassManifest[T]\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"This notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  type OptManifest[T]   = scala.reflect.OptManifest[T]\n  @annotation.implicitNotFound(msg = \"No Manifest available for ${T}.\")\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"Use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  type Manifest[T]      = scala.reflect.Manifest[T]\n  @deprecated(\"Use `scala.reflect.ClassTag` instead\", \"2.10.0\")\n  val ClassManifest     = scala.reflect.ClassManifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"Use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead\", \"2.10.0\")\n  val Manifest          = scala.reflect.Manifest\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"This notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  val NoManifest        = scala.reflect.NoManifest\n\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"Use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead\", \"2.10.0\")\n  def manifest[T](implicit m: Manifest[T])           = m\n  @deprecated(\"Use scala.reflect.classTag[T] instead\", \"2.10.0\")\n  def classManifest[T](implicit m: ClassManifest[T]) = m\n  // TODO undeprecated until Scala reflection becomes non-experimental\n  // @deprecated(\"This notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.\", \"2.10.0\")\n  def optManifest[T](implicit m: OptManifest[T])     = m\n\n  // Minor variations on identity functions\n  def identity[A](x: A): A         = x    // @see `conforms` for the implicit version\n  @inline def implicitly[T](implicit e: T) = e    // for summoning implicit values from the nether world -- TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`\n  @inline def locally[T](x: T): T  = x    // to communicate intent and avoid unmoored statements\n\n  // errors and asserts -------------------------------------------------\n\n  // !!! Remove this when possible - ideally for 2.11.\n  // We are stuck with it a while longer because sbt's compiler interface\n  // still calls it as of 0.12.2.\n  @deprecated(\"Use `sys.error(message)` instead\", \"2.9.0\")\n  def error(message: String): Nothing = sys.error(message)\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is at least `ASSERTION`.\n   *\n   *  @see elidable\n   *  @param assertion   the expression to test\n   */\n  @elidable(ASSERTION)\n  def assert(assertion: Boolean) {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  Calls to this method will not be generated if `-Xelide-below`\n   *  is at least `ASSERTION`.\n   *\n   *  @see elidable\n   *  @param assertion   the expression to test\n   *  @param message     a String to include in the failure message\n   */\n  @elidable(ASSERTION) @inline\n  final def assert(assertion: Boolean, message: => Any) {\n    if (!assertion)\n      throw new java.lang.AssertionError(\"assertion failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is at least `ASSERTION`.\n   *\n   *  @see elidable\n   *  @param assumption   the expression to test\n   */\n  @elidable(ASSERTION)\n  def assume(assumption: Boolean) {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed\")\n  }\n\n  /** Tests an expression, throwing an `AssertionError` if false.\n   *  This method differs from assert only in the intent expressed:\n   *  assert contains a predicate which needs to be proven, while\n   *  assume contains an axiom for a static checker.  Calls to this method\n   *  will not be generated if `-Xelide-below` is at least `ASSERTION`.\n   *\n   *  @see elidable\n   *  @param assumption   the expression to test\n   *  @param message      a String to include in the failure message\n   */\n  @elidable(ASSERTION) @inline\n  final def assume(assumption: Boolean, message: => Any) {\n    if (!assumption)\n      throw new java.lang.AssertionError(\"assumption failed: \"+ message)\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   */\n  def require(requirement: Boolean) {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed\")\n  }\n\n  /** Tests an expression, throwing an `IllegalArgumentException` if false.\n   *  This method is similar to `assert`, but blames the caller of the method\n   *  for violating the condition.\n   *\n   *  @param requirement   the expression to test\n   *  @param message       a String to include in the failure message\n   */\n  @inline final def require(requirement: Boolean, message: => Any) {\n    if (!requirement)\n      throw new IllegalArgumentException(\"requirement failed: \"+ message)\n  }\n\n  /** `???` can be used for marking methods that remain to be implemented.\n   *  @throws NotImplementedError\n   */\n  def ??? : Nothing = throw new NotImplementedError\n\n  // tupling ------------------------------------------------------------\n\n  @deprecated(\"Use built-in tuple syntax or Tuple2 instead\", \"2.11.0\")\n  type Pair[+A, +B] = Tuple2[A, B]\n  @deprecated(\"Use built-in tuple syntax or Tuple2 instead\", \"2.11.0\")\n  object Pair {\n    def apply[A, B](x: A, y: B) = Tuple2(x, y)\n    def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)\n  }\n\n  @deprecated(\"Use built-in tuple syntax or Tuple3 instead\", \"2.11.0\")\n  type Triple[+A, +B, +C] = Tuple3[A, B, C]\n  @deprecated(\"Use built-in tuple syntax or Tuple3 instead\", \"2.11.0\")\n  object Triple {\n    def apply[A, B, C](x: A, y: B, z: C) = Tuple3(x, y, z)\n    def unapply[A, B, C](x: Tuple3[A, B, C]): Option[Tuple3[A, B, C]] = Some(x)\n  }\n\n  // implicit classes -----------------------------------------------------\n\n  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {\n    @inline def -> [B](y: B): Tuple2[A, B] = Tuple2(self, y)\n    def â†’[B](y: B): Tuple2[A, B] = ->(y)\n  }\n\n  implicit final class Ensuring[A](private val self: A) extends AnyVal {\n    def ensuring(cond: Boolean): A = { assert(cond); self }\n    def ensuring(cond: Boolean, msg: => Any): A = { assert(cond, msg); self }\n    def ensuring(cond: A => Boolean): A = { assert(cond(self)); self }\n    def ensuring(cond: A => Boolean, msg: => Any): A = { assert(cond(self), msg); self }\n  }\n\n  implicit final class StringFormat[A](private val self: A) extends AnyVal {\n    /** Returns string formatted according to given `format` string.\n     *  Format strings are as for `String.format`\n     *  (@see java.lang.String.format).\n     */\n    @inline def formatted(fmtstr: String): String = fmtstr format self\n  }\n\n  // TODO: remove, only needed for binary compatibility of 2.11.0-RC1 with 2.11.0-M8\n  // note that `private[scala]` becomes `public` in bytecode\n  private[scala] final class StringAdd[A](private val self: A) extends AnyVal {\n    def +(other: String): String = String.valueOf(self) + other\n  }\n  private[scala] def StringAdd(x: Any): Any = new StringAdd(x)\n\n  // SI-8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit\n  implicit final class any2stringadd[A](private val self: A) extends AnyVal {\n    def +(other: String): String = String.valueOf(self) + other\n  }\n\n  implicit final class RichException(private val self: Throwable) extends AnyVal {\n    import scala.compat.Platform.EOL\n    @deprecated(\"Use Throwable#getStackTrace\", \"2.11.0\") def getStackTraceString = self.getStackTrace().mkString(\"\", EOL, EOL)\n  }\n\n  implicit final class SeqCharSequence(val __sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {\n    def length: Int                                     = __sequenceOfChars.length\n    def charAt(index: Int): Char                        = __sequenceOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(__sequenceOfChars.slice(start, end))\n    override def toString                               = __sequenceOfChars mkString \"\"\n  }\n\n  implicit final class ArrayCharSequence(val __arrayOfChars: Array[Char]) extends CharSequence {\n    def length: Int                                     = __arrayOfChars.length\n    def charAt(index: Int): Char                        = __arrayOfChars(index)\n    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(__arrayOfChars, start, end)\n    override def toString                               = __arrayOfChars mkString \"\"\n  }\n\n  implicit val StringCanBuildFrom: CanBuildFrom[String, Char, String] = new CanBuildFrom[String, Char, String] {\n    def apply(from: String) = apply()\n    def apply()             = mutable.StringBuilder.newBuilder\n  }\n\n  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)\n  @inline implicit def unaugmentString(x: StringOps): String = x.repr\n\n  // printing -----------------------------------------------------------\n\n  def print(x: Any) = Console.print(x)\n  def println() = Console.println()\n  def println(x: Any) = Console.println(x)\n  def printf(text: String, xs: Any*) = Console.print(text.format(xs: _*))\n\n  // views --------------------------------------------------------------\n\n  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2))                           = new runtime.Tuple2Zipped.Ops(x)\n  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3))                   = new runtime.Tuple3Zipped.Ops(x)\n\n  implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T] = (xs match {\n    case x: Array[AnyRef]  => refArrayOps[AnyRef](x)\n    case x: Array[Boolean] => booleanArrayOps(x)\n    case x: Array[Byte]    => byteArrayOps(x)\n    case x: Array[Char]    => charArrayOps(x)\n    case x: Array[Double]  => doubleArrayOps(x)\n    case x: Array[Float]   => floatArrayOps(x)\n    case x: Array[Int]     => intArrayOps(x)\n    case x: Array[Long]    => longArrayOps(x)\n    case x: Array[Short]   => shortArrayOps(x)\n    case x: Array[Unit]    => unitArrayOps(x)\n    case null              => null\n  }).asInstanceOf[ArrayOps[T]]\n\n  implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps[Boolean] = new ArrayOps.ofBoolean(xs)\n  implicit def byteArrayOps(xs: Array[Byte]): ArrayOps[Byte]          = new ArrayOps.ofByte(xs)\n  implicit def charArrayOps(xs: Array[Char]): ArrayOps[Char]          = new ArrayOps.ofChar(xs)\n  implicit def doubleArrayOps(xs: Array[Double]): ArrayOps[Double]    = new ArrayOps.ofDouble(xs)\n  implicit def floatArrayOps(xs: Array[Float]): ArrayOps[Float]       = new ArrayOps.ofFloat(xs)\n  implicit def intArrayOps(xs: Array[Int]): ArrayOps[Int]             = new ArrayOps.ofInt(xs)\n  implicit def longArrayOps(xs: Array[Long]): ArrayOps[Long]          = new ArrayOps.ofLong(xs)\n  implicit def refArrayOps[T <: AnyRef](xs: Array[T]): ArrayOps[T]    = new ArrayOps.ofRef[T](xs)\n  implicit def shortArrayOps(xs: Array[Short]): ArrayOps[Short]       = new ArrayOps.ofShort(xs)\n  implicit def unitArrayOps(xs: Array[Unit]): ArrayOps[Unit]          = new ArrayOps.ofUnit(xs)\n\n  // \"Autoboxing\" and \"Autounboxing\" ---------------------------------------------------\n\n  implicit def byte2Byte(x: Byte)           = java.lang.Byte.valueOf(x)\n  implicit def short2Short(x: Short)        = java.lang.Short.valueOf(x)\n  implicit def char2Character(x: Char)      = java.lang.Character.valueOf(x)\n  implicit def int2Integer(x: Int)          = java.lang.Integer.valueOf(x)\n  implicit def long2Long(x: Long)           = java.lang.Long.valueOf(x)\n  implicit def float2Float(x: Float)        = java.lang.Float.valueOf(x)\n  implicit def double2Double(x: Double)     = java.lang.Double.valueOf(x)\n  implicit def boolean2Boolean(x: Boolean)  = java.lang.Boolean.valueOf(x)\n\n  implicit def Byte2byte(x: java.lang.Byte): Byte             = x.byteValue\n  implicit def Short2short(x: java.lang.Short): Short         = x.shortValue\n  implicit def Character2char(x: java.lang.Character): Char   = x.charValue\n  implicit def Integer2int(x: java.lang.Integer): Int         = x.intValue\n  implicit def Long2long(x: java.lang.Long): Long             = x.longValue\n  implicit def Float2float(x: java.lang.Float): Float         = x.floatValue\n  implicit def Double2double(x: java.lang.Double): Double     = x.doubleValue\n  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean = x.booleanValue\n\n  // Type Constraints --------------------------------------------------------------\n\n  /**\n   * An instance of `A <:< B` witnesses that `A` is a subtype of `B`.\n   * Requiring an implicit argument of the type `A <:< B` encodes\n   * the generalized constraint `A <: B`.\n   *\n   * @note we need a new type constructor `<:<` and evidence `conforms`,\n   * as reusing `Function1` and `identity` leads to ambiguities in\n   * case of type errors (`any2stringadd` is inferred)\n   *\n   * To constrain any abstract type T that's in scope in a method's\n   * argument list (not just the method's own type parameters) simply\n   * add an implicit argument of type `T <:< U`, where `U` is the required\n   * upper bound; or for lower-bounds, use: `L <:< T`, where `L` is the\n   * required lower bound.\n   *\n   * In part contributed by Jason Zaugg.\n   */\n  @implicitNotFound(msg = \"Cannot prove that ${From} <:< ${To}.\")\n  sealed abstract class <:<[-From, +To] extends (From => To) with Serializable\n  private[this] final val singleton_<:< = new <:<[Any,Any] { def apply(x: Any): Any = x }\n  // The dollar prefix is to dodge accidental shadowing of this method\n  // by a user-defined method of the same name (SI-7788).\n  // The collections rely on this method.\n  implicit def $conforms[A]: A <:< A = singleton_<:<.asInstanceOf[A <:< A]\n\n  @deprecated(\"Use `implicitly[T <:< U]` or `identity` instead.\", \"2.11.0\")\n  def conforms[A]: A <:< A = $conforms[A]\n\n  /** An instance of `A =:= B` witnesses that the types `A` and `B` are equal.\n   *\n   * @see `<:<` for expressing subtyping constraints\n   */\n  @implicitNotFound(msg = \"Cannot prove that ${From} =:= ${To}.\")\n  sealed abstract class =:=[From, To] extends (From => To) with Serializable\n  private[this] final val singleton_=:= = new =:=[Any,Any] { def apply(x: Any): Any = x }\n  object =:= {\n     implicit def tpEquals[A]: A =:= A = singleton_=:=.asInstanceOf[A =:= A]\n  }\n\n  /** A type for which there is always an implicit value.\n   *  @see [[scala.Array$]], method `fallbackCanBuildFrom`\n   */\n  class DummyImplicit\n\n  object DummyImplicit {\n\n    /** An implicit value yielding a `DummyImplicit`.\n     *   @see [[scala.Array$]], method `fallbackCanBuildFrom`\n     */\n    implicit def dummyImplicit: DummyImplicit = new DummyImplicit\n  }\n}\n\nprivate[scala] trait DeprecatedPredef {\n  self: Predef.type =>\n\n  // Deprecated stubs for any who may have been calling these methods directly.\n  @deprecated(\"Use `ArrowAssoc`\", \"2.11.0\") def any2ArrowAssoc[A](x: A): ArrowAssoc[A]                                      = new ArrowAssoc(x)\n  @deprecated(\"Use `Ensuring`\", \"2.11.0\") def any2Ensuring[A](x: A): Ensuring[A]                                            = new Ensuring(x)\n  @deprecated(\"Use `StringFormat`\", \"2.11.0\") def any2stringfmt(x: Any): StringFormat[Any]                                  = new StringFormat(x)\n  @deprecated(\"Use `Throwable` directly\", \"2.11.0\") def exceptionWrapper(exc: Throwable)                                    = new RichException(exc)\n  @deprecated(\"Use `SeqCharSequence`\", \"2.11.0\") def seqToCharSequence(xs: scala.collection.IndexedSeq[Char]): CharSequence = new SeqCharSequence(xs)\n  @deprecated(\"Use `ArrayCharSequence`\", \"2.11.0\") def arrayToCharSequence(xs: Array[Char]): CharSequence                   = new ArrayCharSequence(xs)\n\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readLine(): String                 = StdIn.readLine()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readLine(text: String, args: Any*) = StdIn.readLine(text, args: _*)\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readBoolean()                      = StdIn.readBoolean()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readByte()                         = StdIn.readByte()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readShort()                        = StdIn.readShort()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readChar()                         = StdIn.readChar()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readInt()                          = StdIn.readInt()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readLong()                         = StdIn.readLong()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readFloat()                        = StdIn.readFloat()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readDouble()                       = StdIn.readDouble()\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readf(format: String)              = StdIn.readf(format)\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readf1(format: String)             = StdIn.readf1(format)\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readf2(format: String)             = StdIn.readf2(format)\n  @deprecated(\"Use the method in `scala.io.StdIn`\", \"2.11.0\") def readf3(format: String)             = StdIn.readf3(format)\n}\n\n/** The `LowPriorityImplicits` class provides implicit values that\n*  are valid in all Scala compilation units without explicit qualification,\n*  but that are partially overridden by higher-priority conversions in object\n*  `Predef`.\n*\n*  @author  Martin Odersky\n*  @since 2.8\n*/\n// SI-7335 Parents of Predef are defined in the same compilation unit to avoid\n// cyclic reference errors compiling the standard library *without* a previously\n// compiled copy on the classpath.\nprivate[scala] abstract class LowPriorityImplicits {\n  import mutable.WrappedArray\n  import immutable.WrappedString\n\n  /** We prefer the java.lang.* boxed types to these wrappers in\n   *  any potential conflicts.  Conflicts do exist because the wrappers\n   *  need to implement ScalaNumber in order to have a symmetric equals\n   *  method, but that implies implementing java.lang.Number as well.\n   *\n   *  Note - these are inlined because they are value classes, but\n   *  the call to xxxWrapper is not eliminated even though it does nothing.\n   *  Even inlined, every call site does a no-op retrieval of Predef's MODULE$\n   *  because maybe loading Predef has side effects!\n   */\n  @inline implicit def byteWrapper(x: Byte)       = new runtime.RichByte(x)\n  @inline implicit def shortWrapper(x: Short)     = new runtime.RichShort(x)\n  @inline implicit def intWrapper(x: Int)         = new runtime.RichInt(x)\n  @inline implicit def charWrapper(c: Char)       = new runtime.RichChar(c)\n  @inline implicit def longWrapper(x: Long)       = new runtime.RichLong(x)\n  @inline implicit def floatWrapper(x: Float)     = new runtime.RichFloat(x)\n  @inline implicit def doubleWrapper(x: Double)   = new runtime.RichDouble(x)\n  @inline implicit def booleanWrapper(x: Boolean) = new runtime.RichBoolean(x)\n\n  implicit def genericWrapArray[T](xs: Array[T]): WrappedArray[T] =\n    if (xs eq null) null\n    else WrappedArray.make(xs)\n\n  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]\n  // is as good as another for all T <: AnyRef.  Instead of creating 100,000,000\n  // unique ones by way of this implicit, let's share one.\n  implicit def wrapRefArray[T <: AnyRef](xs: Array[T]): WrappedArray[T] = {\n    if (xs eq null) null\n    else if (xs.length == 0) WrappedArray.empty[T]\n    else new WrappedArray.ofRef[T](xs)\n  }\n\n  implicit def wrapIntArray(xs: Array[Int]): WrappedArray[Int] = if (xs ne null) new WrappedArray.ofInt(xs) else null\n  implicit def wrapDoubleArray(xs: Array[Double]): WrappedArray[Double] = if (xs ne null) new WrappedArray.ofDouble(xs) else null\n  implicit def wrapLongArray(xs: Array[Long]): WrappedArray[Long] = if (xs ne null) new WrappedArray.ofLong(xs) else null\n  implicit def wrapFloatArray(xs: Array[Float]): WrappedArray[Float] = if (xs ne null) new WrappedArray.ofFloat(xs) else null\n  implicit def wrapCharArray(xs: Array[Char]): WrappedArray[Char] = if (xs ne null) new WrappedArray.ofChar(xs) else null\n  implicit def wrapByteArray(xs: Array[Byte]): WrappedArray[Byte] = if (xs ne null) new WrappedArray.ofByte(xs) else null\n  implicit def wrapShortArray(xs: Array[Short]): WrappedArray[Short] = if (xs ne null) new WrappedArray.ofShort(xs) else null\n  implicit def wrapBooleanArray(xs: Array[Boolean]): WrappedArray[Boolean] = if (xs ne null) new WrappedArray.ofBoolean(xs) else null\n  implicit def wrapUnitArray(xs: Array[Unit]): WrappedArray[Unit] = if (xs ne null) new WrappedArray.ofUnit(xs) else null\n\n  implicit def wrapString(s: String): WrappedString = if (s ne null) new WrappedString(s) else null\n  implicit def unwrapString(ws: WrappedString): String = if (ws ne null) ws.self else null\n\n  implicit def fallbackStringCanBuildFrom[T]: CanBuildFrom[String, T, immutable.IndexedSeq[T]] =\n    new CanBuildFrom[String, T, immutable.IndexedSeq[T]] {\n      def apply(from: String) = immutable.IndexedSeq.newBuilder[T]\n      def apply() = immutable.IndexedSeq.newBuilder[T]\n    }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/scala-library-2.11.12-sources.jar/scala/Predef.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var query = ("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":85}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var query = ("INSERT INTO project0 (todoList) values ("+arrBuff.foreach()+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol foreach[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":60}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var query = ("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol todoList[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(query)[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":38}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":24}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":38})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":25}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":39})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":32}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(query)[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     } [0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":55}}[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":55}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":58,"character":49}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":44})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":45})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":28}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(arrBuff(x))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol arrBuff[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":22}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":47})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":22}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":48})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":27}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":49})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":40}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":50})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":55}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":51})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":70}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol todoList[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":28}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+query+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":54})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":28}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+query+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":23}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+query+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":56})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":25}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var query = arrBuff(x)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":57})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":34}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //var query = ("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":55,"character":34}}[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":60})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":61})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":37}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Statement.java","languageId":"java","version":1,"text":"/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.sql;\n\nimport java.util.regex.Pattern;\nimport static java.util.stream.Collectors.joining;\n\n/**\n * <P>The object used for executing a static SQL statement\n * and returning the results it produces.\n * <P>\n * By default, only one <code>ResultSet</code> object per <code>Statement</code>\n * object can be open at the same time. Therefore, if the reading of one\n * <code>ResultSet</code> object is interleaved\n * with the reading of another, each must have been generated by\n * different <code>Statement</code> objects. All execution methods in the\n * <code>Statement</code> interface implicitly close a current\n * <code>ResultSet</code> object of the statement if an open one exists.\n *\n * @see Connection#createStatement\n * @see ResultSet\n * @since 1.1\n */\npublic interface Statement extends Wrapper, AutoCloseable {\n\n    /**\n     * Executes the given SQL statement, which returns a single\n     * <code>ResultSet</code> object.\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql an SQL statement to be sent to the database, typically a\n     *        static SQL <code>SELECT</code> statement\n     * @return a <code>ResultSet</code> object that contains the data produced\n     *         by the given query; never <code>null</code>\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the given\n     *            SQL statement produces anything other than a single\n     *            <code>ResultSet</code> object, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     */\n    ResultSet executeQuery(String sql) throws SQLException;\n\n    /**\n     * Executes the given SQL statement, which may be an <code>INSERT</code>,\n     * <code>UPDATE</code>, or <code>DELETE</code> statement or an\n     * SQL statement that returns nothing, such as an SQL DDL statement.\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements\n     *         or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the given\n     * SQL statement produces a <code>ResultSet</code> object, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     */\n    int executeUpdate(String sql) throws SQLException;\n\n    /**\n     * Releases this <code>Statement</code> object's database\n     * and JDBC resources immediately instead of waiting for\n     * this to happen when it is automatically closed.\n     * It is generally good practice to release resources as soon as\n     * you are finished with them to avoid tying up database\n     * resources.\n     * <P>\n     * Calling the method <code>close</code> on a <code>Statement</code>\n     * object that is already closed has no effect.\n     * <P>\n     * <B>Note:</B>When a <code>Statement</code> object is\n     * closed, its current <code>ResultSet</code> object, if one exists, is\n     * also closed.\n     *\n     * @exception SQLException if a database access error occurs\n     */\n    void close() throws SQLException;\n\n    //----------------------------------------------------------------------\n\n    /**\n     * Retrieves the maximum number of bytes that can be\n     * returned for character and binary column values in a <code>ResultSet</code>\n     * object produced by this <code>Statement</code> object.\n     * This limit applies only to  <code>BINARY</code>, <code>VARBINARY</code>,\n     * <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,\n     * <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>\n     * and <code>LONGVARCHAR</code> columns.  If the limit is exceeded, the\n     * excess data is silently discarded.\n     *\n     * @return the current column size limit for columns storing character and\n     *         binary values; zero means there is no limit\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #setMaxFieldSize\n     */\n    int getMaxFieldSize() throws SQLException;\n\n    /**\n     * Sets the limit for the maximum number of bytes that can be returned for\n     * character and binary column values in a <code>ResultSet</code>\n     * object produced by this <code>Statement</code> object.\n     *\n     * This limit applies\n     * only to <code>BINARY</code>, <code>VARBINARY</code>,\n     * <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,\n     * <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code> and\n     * <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data\n     * is silently discarded. For maximum portability, use values\n     * greater than 256.\n     *\n     * @param max the new column size limit in bytes; zero means there is no limit\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>\n     *            or the condition {@code max >= 0} is not satisfied\n     * @see #getMaxFieldSize\n     */\n    void setMaxFieldSize(int max) throws SQLException;\n\n    /**\n     * Retrieves the maximum number of rows that a\n     * <code>ResultSet</code> object produced by this\n     * <code>Statement</code> object can contain.  If this limit is exceeded,\n     * the excess rows are silently dropped.\n     *\n     * @return the current maximum number of rows for a <code>ResultSet</code>\n     *         object produced by this <code>Statement</code> object;\n     *         zero means there is no limit\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #setMaxRows\n     */\n    int getMaxRows() throws SQLException;\n\n    /**\n     * Sets the limit for the maximum number of rows that any\n     * <code>ResultSet</code> object  generated by this <code>Statement</code>\n     * object can contain to the given number.\n     * If the limit is exceeded, the excess\n     * rows are silently dropped.\n     *\n     * @param max the new max rows limit; zero means there is no limit\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>\n     *            or the condition {@code max >= 0} is not satisfied\n     * @see #getMaxRows\n     */\n    void setMaxRows(int max) throws SQLException;\n\n    /**\n     * Sets escape processing on or off.\n     * If escape scanning is on (the default), the driver will do\n     * escape substitution before sending the SQL statement to the database.\n     *<p>\n     * The {@code Connection} and {@code DataSource} property\n     * {@code escapeProcessing} may be used to change the default escape processing\n     * behavior.  A value of true (the default) enables escape Processing for\n     * all {@code Statement} objects. A value of false disables escape processing\n     * for all {@code Statement} objects.  The {@code setEscapeProcessing}\n     * method may be used to specify the escape processing behavior for an\n     * individual {@code Statement} object.\n     * <p>\n     * Note: Since prepared statements have usually been parsed prior\n     * to making this call, disabling escape processing for\n     * <code>PreparedStatements</code> objects will have no effect.\n     *\n     * @param enable <code>true</code> to enable escape processing;\n     *       <code>false</code> to disable it\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     */\n    void setEscapeProcessing(boolean enable) throws SQLException;\n\n    /**\n     * Retrieves the number of seconds the driver will\n     * wait for a <code>Statement</code> object to execute.\n     * If the limit is exceeded, a\n     * <code>SQLException</code> is thrown.\n     *\n     * @return the current query timeout limit in seconds; zero means there is\n     *         no limit\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #setQueryTimeout\n     */\n    int getQueryTimeout() throws SQLException;\n\n    /**\n     * Sets the number of seconds the driver will wait for a\n     * <code>Statement</code> object to execute to the given number of seconds.\n     *By default there is no limit on the amount of time allowed for a running\n     * statement to complete. If the limit is exceeded, an\n     * <code>SQLTimeoutException</code> is thrown.\n     * A JDBC driver must apply this limit to the <code>execute</code>,\n     * <code>executeQuery</code> and <code>executeUpdate</code> methods.\n     * <p>\n     * <strong>Note:</strong> JDBC driver implementations may also apply this\n     * limit to {@code ResultSet} methods\n     * (consult your driver vendor documentation for details).\n     * <p>\n     * <strong>Note:</strong> In the case of {@code Statement} batching, it is\n     * implementation defined as to whether the time-out is applied to\n     * individual SQL commands added via the {@code addBatch} method or to\n     * the entire batch of SQL commands invoked by the {@code executeBatch}\n     * method (consult your driver vendor documentation for details).\n     *\n     * @param seconds the new query timeout limit in seconds; zero means\n     *        there is no limit\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>\n     *            or the condition {@code seconds >= 0} is not satisfied\n     * @see #getQueryTimeout\n     */\n    void setQueryTimeout(int seconds) throws SQLException;\n\n    /**\n     * Cancels this <code>Statement</code> object if both the DBMS and\n     * driver support aborting an SQL statement.\n     * This method can be used by one thread to cancel a statement that\n     * is being executed by another thread.\n     *\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     */\n    void cancel() throws SQLException;\n\n    /**\n     * Retrieves the first warning reported by calls on this <code>Statement</code> object.\n     * Subsequent <code>Statement</code> object warnings will be chained to this\n     * <code>SQLWarning</code> object.\n     *\n     * <p>The warning chain is automatically cleared each time\n     * a statement is (re)executed. This method may not be called on a closed\n     * <code>Statement</code> object; doing so will cause an <code>SQLException</code>\n     * to be thrown.\n     *\n     * <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any\n     * warnings associated with reads on that <code>ResultSet</code> object\n     * will be chained on it rather than on the <code>Statement</code>\n     * object that produced it.\n     *\n     * @return the first <code>SQLWarning</code> object or <code>null</code>\n     *         if there are no warnings\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     */\n    SQLWarning getWarnings() throws SQLException;\n\n    /**\n     * Clears all the warnings reported on this <code>Statement</code>\n     * object. After a call to this method,\n     * the method <code>getWarnings</code> will return\n     * <code>null</code> until a new warning is reported for this\n     * <code>Statement</code> object.\n     *\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     */\n    void clearWarnings() throws SQLException;\n\n    /**\n     * Sets the SQL cursor name to the given <code>String</code>, which\n     * will be used by subsequent <code>Statement</code> object\n     * <code>execute</code> methods. This name can then be\n     * used in SQL positioned update or delete statements to identify the\n     * current row in the <code>ResultSet</code> object generated by this\n     * statement.  If the database does not support positioned update/delete,\n     * this method is a noop.  To insure that a cursor has the proper isolation\n     * level to support updates, the cursor's <code>SELECT</code> statement\n     * should have the form <code>SELECT FOR UPDATE</code>.  If\n     * <code>FOR UPDATE</code> is not present, positioned updates may fail.\n     *\n     * <P><B>Note:</B> By definition, the execution of positioned updates and\n     * deletes must be done by a different <code>Statement</code> object than\n     * the one that generated the <code>ResultSet</code> object being used for\n     * positioning. Also, cursor names must be unique within a connection.\n     *\n     * @param name the new cursor name, which must be unique within\n     *             a connection\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     */\n    void setCursorName(String name) throws SQLException;\n\n    //----------------------- Multiple Results --------------------------\n\n    /**\n     * Executes the given SQL statement, which may return multiple results.\n     * In some (uncommon) situations, a single SQL statement may return\n     * multiple result sets and/or update counts.  Normally you can ignore\n     * this unless you are (1) executing a stored procedure that you know may\n     * return multiple results or (2) you are dynamically executing an\n     * unknown SQL string.\n     * <P>\n     * The <code>execute</code> method executes an SQL statement and indicates the\n     * form of the first result.  You must then use the methods\n     * <code>getResultSet</code> or <code>getUpdateCount</code>\n     * to retrieve the result, and <code>getMoreResults</code> to\n     * move to any subsequent result(s).\n     * <p>\n     *<strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql any SQL statement\n     * @return <code>true</code> if the first result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there are\n     *         no results\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>,\n     * the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @see #getResultSet\n     * @see #getUpdateCount\n     * @see #getMoreResults\n     */\n    boolean execute(String sql) throws SQLException;\n\n    /**\n     *  Retrieves the current result as a <code>ResultSet</code> object.\n     *  This method should be called only once per result.\n     *\n     * @return the current result as a <code>ResultSet</code> object or\n     * <code>null</code> if the result is an update count or there are no more results\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #execute\n     */\n    ResultSet getResultSet() throws SQLException;\n\n    /**\n     *  Retrieves the current result as an update count;\n     *  if the result is a <code>ResultSet</code> object or there are no more results, -1\n     *  is returned. This method should be called only once per result.\n     *\n     * @return the current result as an update count; -1 if the current result is a\n     * <code>ResultSet</code> object or there are no more results\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #execute\n     */\n    int getUpdateCount() throws SQLException;\n\n    /**\n     * Moves to this <code>Statement</code> object's next result, returns\n     * <code>true</code> if it is a <code>ResultSet</code> object, and\n     * implicitly closes any current <code>ResultSet</code>\n     * object(s) obtained with the method <code>getResultSet</code>.\n     *\n     * <P>There are no more results when the following is true:\n     * <PRE>{@code\n     *     // stmt is a Statement object\n     *     ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1))\n     * }</PRE>\n     *\n     * @return <code>true</code> if the next result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there are\n     *         no more results\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #execute\n     */\n    boolean getMoreResults() throws SQLException;\n\n\n    //--------------------------JDBC 2.0-----------------------------\n\n\n    /**\n     * Gives the driver a hint as to the direction in which\n     * rows will be processed in <code>ResultSet</code>\n     * objects created using this <code>Statement</code> object.  The\n     * default value is <code>ResultSet.FETCH_FORWARD</code>.\n     * <P>\n     * Note that this method sets the default fetch direction for\n     * result sets generated by this <code>Statement</code> object.\n     * Each result set has its own methods for getting and setting\n     * its own fetch direction.\n     *\n     * @param direction the initial direction for processing rows\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>\n     * or the given direction\n     * is not one of <code>ResultSet.FETCH_FORWARD</code>,\n     * <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code>\n     * @since 1.2\n     * @see #getFetchDirection\n     */\n    void setFetchDirection(int direction) throws SQLException;\n\n    /**\n     * Retrieves the direction for fetching rows from\n     * database tables that is the default for result sets\n     * generated from this <code>Statement</code> object.\n     * If this <code>Statement</code> object has not set\n     * a fetch direction by calling the method <code>setFetchDirection</code>,\n     * the return value is implementation-specific.\n     *\n     * @return the default fetch direction for result sets generated\n     *          from this <code>Statement</code> object\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @since 1.2\n     * @see #setFetchDirection\n     */\n    int getFetchDirection() throws SQLException;\n\n    /**\n     * Gives the JDBC driver a hint as to the number of rows that should\n     * be fetched from the database when more rows are needed for\n     * <code>ResultSet</code> objects generated by this <code>Statement</code>.\n     * If the value specified is zero, then the hint is ignored.\n     * The default value is zero.\n     *\n     * @param rows the number of rows to fetch\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code> or the\n     *        condition {@code rows >= 0} is not satisfied.\n     * @since 1.2\n     * @see #getFetchSize\n     */\n    void setFetchSize(int rows) throws SQLException;\n\n    /**\n     * Retrieves the number of result set rows that is the default\n     * fetch size for <code>ResultSet</code> objects\n     * generated from this <code>Statement</code> object.\n     * If this <code>Statement</code> object has not set\n     * a fetch size by calling the method <code>setFetchSize</code>,\n     * the return value is implementation-specific.\n     *\n     * @return the default fetch size for result sets generated\n     *          from this <code>Statement</code> object\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @since 1.2\n     * @see #setFetchSize\n     */\n    int getFetchSize() throws SQLException;\n\n    /**\n     * Retrieves the result set concurrency for <code>ResultSet</code> objects\n     * generated by this <code>Statement</code> object.\n     *\n     * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or\n     * <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @since 1.2\n     */\n    int getResultSetConcurrency() throws SQLException;\n\n    /**\n     * Retrieves the result set type for <code>ResultSet</code> objects\n     * generated by this <code>Statement</code> object.\n     *\n     * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     * <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @since 1.2\n     */\n    int getResultSetType()  throws SQLException;\n\n    /**\n     * Adds the given SQL command to the current list of commands for this\n     * <code>Statement</code> object. The commands in this list can be\n     * executed as a batch by calling the method <code>executeBatch</code>.\n     * <P>\n     *<strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql typically this is a SQL <code>INSERT</code> or\n     * <code>UPDATE</code> statement\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the\n     * driver does not support batch updates, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @see #executeBatch\n     * @see DatabaseMetaData#supportsBatchUpdates\n     * @since 1.2\n     */\n    void addBatch( String sql ) throws SQLException;\n\n    /**\n     * Empties this <code>Statement</code> object's current list of\n     * SQL commands.\n     *\n     * @exception SQLException if a database access error occurs,\n     *  this method is called on a closed <code>Statement</code> or the\n     * driver does not support batch updates\n     * @see #addBatch\n     * @see DatabaseMetaData#supportsBatchUpdates\n     * @since 1.2\n     */\n    void clearBatch() throws SQLException;\n\n    /**\n     * Submits a batch of commands to the database for execution and\n     * if all commands execute successfully, returns an array of update counts.\n     * The <code>int</code> elements of the array that is returned are ordered\n     * to correspond to the commands in the batch, which are ordered\n     * according to the order in which they were added to the batch.\n     * The elements in the array returned by the method <code>executeBatch</code>\n     * may be one of the following:\n     * <OL>\n     * <LI>A number greater than or equal to zero -- indicates that the\n     * command was processed successfully and is an update count giving the\n     * number of rows in the database that were affected by the command's\n     * execution\n     * <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was\n     * processed successfully but that the number of rows affected is\n     * unknown\n     * <P>\n     * If one of the commands in a batch update fails to execute properly,\n     * this method throws a <code>BatchUpdateException</code>, and a JDBC\n     * driver may or may not continue to process the remaining commands in\n     * the batch.  However, the driver's behavior must be consistent with a\n     * particular DBMS, either always continuing to process commands or never\n     * continuing to process commands.  If the driver continues processing\n     * after a failure, the array returned by the method\n     * <code>BatchUpdateException.getUpdateCounts</code>\n     * will contain as many elements as there are commands in the batch, and\n     * at least one of the elements will be the following:\n     *\n     * <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed\n     * to execute successfully and occurs only if a driver continues to\n     * process commands after a command fails\n     * </OL>\n     * <P>\n     * The possible implementations and return values have been modified in\n     * the Java 2 SDK, Standard Edition, version 1.3 to\n     * accommodate the option of continuing to process commands in a batch\n     * update after a <code>BatchUpdateException</code> object has been thrown.\n     *\n     * @return an array of update counts containing one element for each\n     * command in the batch.  The elements of the array are ordered according\n     * to the order in which commands were added to the batch.\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code> or the\n     * driver does not support batch statements. Throws {@link BatchUpdateException}\n     * (a subclass of <code>SQLException</code>) if one of the commands sent to the\n     * database fails to execute properly or attempts to return a result set.\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     *\n     * @see #addBatch\n     * @see DatabaseMetaData#supportsBatchUpdates\n     * @since 1.2\n     */\n    int[] executeBatch() throws SQLException;\n\n    /**\n     * Retrieves the <code>Connection</code> object\n     * that produced this <code>Statement</code> object.\n     * @return the connection that produced this statement\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @since 1.2\n     */\n    Connection getConnection()  throws SQLException;\n\n  //--------------------------JDBC 3.0-----------------------------\n\n    /**\n     * The constant indicating that the current <code>ResultSet</code> object\n     * should be closed when calling <code>getMoreResults</code>.\n     *\n     * @since 1.4\n     */\n    int CLOSE_CURRENT_RESULT = 1;\n\n    /**\n     * The constant indicating that the current <code>ResultSet</code> object\n     * should not be closed when calling <code>getMoreResults</code>.\n     *\n     * @since 1.4\n     */\n    int KEEP_CURRENT_RESULT = 2;\n\n    /**\n     * The constant indicating that all <code>ResultSet</code> objects that\n     * have previously been kept open should be closed when calling\n     * <code>getMoreResults</code>.\n     *\n     * @since 1.4\n     */\n    int CLOSE_ALL_RESULTS = 3;\n\n    /**\n     * The constant indicating that a batch statement executed successfully\n     * but that no count of the number of rows it affected is available.\n     *\n     * @since 1.4\n     */\n    int SUCCESS_NO_INFO = -2;\n\n    /**\n     * The constant indicating that an error occurred while executing a\n     * batch statement.\n     *\n     * @since 1.4\n     */\n    int EXECUTE_FAILED = -3;\n\n    /**\n     * The constant indicating that generated keys should be made\n     * available for retrieval.\n     *\n     * @since 1.4\n     */\n    int RETURN_GENERATED_KEYS = 1;\n\n    /**\n     * The constant indicating that generated keys should not be made\n     * available for retrieval.\n     *\n     * @since 1.4\n     */\n    int NO_GENERATED_KEYS = 2;\n\n    /**\n     * Moves to this <code>Statement</code> object's next result, deals with\n     * any current <code>ResultSet</code> object(s) according  to the instructions\n     * specified by the given flag, and returns\n     * <code>true</code> if the next result is a <code>ResultSet</code> object.\n     *\n     * <P>There are no more results when the following is true:\n     * <PRE>{@code\n     *     // stmt is a Statement object\n     *     ((stmt.getMoreResults(current) == false) && (stmt.getUpdateCount() == -1))\n     * }</PRE>\n     *\n     * @param current one of the following <code>Statement</code>\n     *        constants indicating what should happen to current\n     *        <code>ResultSet</code> objects obtained using the method\n     *        <code>getResultSet</code>:\n     *        <code>Statement.CLOSE_CURRENT_RESULT</code>,\n     *        <code>Statement.KEEP_CURRENT_RESULT</code>, or\n     *        <code>Statement.CLOSE_ALL_RESULTS</code>\n     * @return <code>true</code> if the next result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there are no\n     *         more results\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code> or the argument\n     *         supplied is not one of the following:\n     *        <code>Statement.CLOSE_CURRENT_RESULT</code>,\n     *        <code>Statement.KEEP_CURRENT_RESULT</code> or\n     *        <code>Statement.CLOSE_ALL_RESULTS</code>\n     *@exception SQLFeatureNotSupportedException if\n     * <code>DatabaseMetaData.supportsMultipleOpenResults</code> returns\n     * <code>false</code> and either\n     *        <code>Statement.KEEP_CURRENT_RESULT</code> or\n     *        <code>Statement.CLOSE_ALL_RESULTS</code> are supplied as\n     * the argument.\n     * @since 1.4\n     * @see #execute\n     */\n    boolean getMoreResults(int current) throws SQLException;\n\n    /**\n     * Retrieves any auto-generated keys created as a result of executing this\n     * <code>Statement</code> object. If this <code>Statement</code> object did\n     * not generate any keys, an empty <code>ResultSet</code>\n     * object is returned.\n     *\n     *<p><B>Note:</B>If the columns which represent the auto-generated keys were not specified,\n     * the JDBC driver implementation will determine the columns which best represent the auto-generated keys.\n     *\n     * @return a <code>ResultSet</code> object containing the auto-generated key(s)\n     *         generated by the execution of this <code>Statement</code> object\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @since 1.4\n     */\n    ResultSet getGeneratedKeys() throws SQLException;\n\n    /**\n     * Executes the given SQL statement and signals the driver with the\n     * given flag about whether the\n     * auto-generated keys produced by this <code>Statement</code> object\n     * should be made available for retrieval.  The driver will ignore the\n     * flag if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @param autoGeneratedKeys a flag indicating whether auto-generated keys\n     *        should be made available for retrieval;\n     *         one of the following constants:\n     *         <code>Statement.RETURN_GENERATED_KEYS</code>\n     *         <code>Statement.NO_GENERATED_KEYS</code>\n     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements\n     *         or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     *  this method is called on a closed <code>Statement</code>, the given\n     *            SQL statement returns a <code>ResultSet</code> object,\n     *            the given constant is not one of those allowed, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.4\n     */\n    int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException;\n\n    /**\n     * Executes the given SQL statement and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval.   This array contains the indexes of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available. The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @param columnIndexes an array of column indexes indicating the columns\n     *        that should be returned from the inserted row\n     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements\n     *         or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the SQL\n     * statement returns a <code>ResultSet</code> object,the second argument\n     * supplied to this method is not an\n     * <code>int</code> array whose elements are valid column indexes, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.4\n     */\n    int executeUpdate(String sql, int columnIndexes[]) throws SQLException;\n\n    /**\n     * Executes the given SQL statement and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval.   This array contains the names of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available. The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     * @param columnNames an array of the names of the columns that should be\n     *        returned from the inserted row\n     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>,\n     *         or <code>DELETE</code> statements, or 0 for SQL statements\n     *         that return nothing\n     * @exception SQLException if a database access error occurs,\n     *  this method is called on a closed <code>Statement</code>, the SQL\n     *            statement returns a <code>ResultSet</code> object, the\n     *            second argument supplied to this method is not a <code>String</code> array\n     *            whose elements are valid column names, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.4\n     */\n    int executeUpdate(String sql, String columnNames[]) throws SQLException;\n\n    /**\n     * Executes the given SQL statement, which may return multiple results,\n     * and signals the driver that any\n     * auto-generated keys should be made available\n     * for retrieval.  The driver will ignore this signal if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * In some (uncommon) situations, a single SQL statement may return\n     * multiple result sets and/or update counts.  Normally you can ignore\n     * this unless you are (1) executing a stored procedure that you know may\n     * return multiple results or (2) you are dynamically executing an\n     * unknown SQL string.\n     * <P>\n     * The <code>execute</code> method executes an SQL statement and indicates the\n     * form of the first result.  You must then use the methods\n     * <code>getResultSet</code> or <code>getUpdateCount</code>\n     * to retrieve the result, and <code>getMoreResults</code> to\n     * move to any subsequent result(s).\n     *<p>\n     *<strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql any SQL statement\n     * @param autoGeneratedKeys a constant indicating whether auto-generated\n     *        keys should be made available for retrieval using the method\n     *        <code>getGeneratedKeys</code>; one of the following constants:\n     *        <code>Statement.RETURN_GENERATED_KEYS</code> or\n     *        <code>Statement.NO_GENERATED_KEYS</code>\n     * @return <code>true</code> if the first result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there are\n     *         no results\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the second\n     *         parameter supplied to this method is not\n     *         <code>Statement.RETURN_GENERATED_KEYS</code> or\n     *         <code>Statement.NO_GENERATED_KEYS</code>,\n     * the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @see #getResultSet\n     * @see #getUpdateCount\n     * @see #getMoreResults\n     * @see #getGeneratedKeys\n     *\n     * @since 1.4\n     */\n    boolean execute(String sql, int autoGeneratedKeys) throws SQLException;\n\n    /**\n     * Executes the given SQL statement, which may return multiple results,\n     * and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval.  This array contains the indexes of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available.  The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * Under some (uncommon) situations, a single SQL statement may return\n     * multiple result sets and/or update counts.  Normally you can ignore\n     * this unless you are (1) executing a stored procedure that you know may\n     * return multiple results or (2) you are dynamically executing an\n     * unknown SQL string.\n     * <P>\n     * The <code>execute</code> method executes an SQL statement and indicates the\n     * form of the first result.  You must then use the methods\n     * <code>getResultSet</code> or <code>getUpdateCount</code>\n     * to retrieve the result, and <code>getMoreResults</code> to\n     * move to any subsequent result(s).\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql any SQL statement\n     * @param columnIndexes an array of the indexes of the columns in the\n     *        inserted row that should be  made available for retrieval by a\n     *        call to the method <code>getGeneratedKeys</code>\n     * @return <code>true</code> if the first result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there\n     *         are no results\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the\n     *            elements in the <code>int</code> array passed to this method\n     *            are not valid column indexes, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @see #getResultSet\n     * @see #getUpdateCount\n     * @see #getMoreResults\n     *\n     * @since 1.4\n     */\n    boolean execute(String sql, int columnIndexes[]) throws SQLException;\n\n    /**\n     * Executes the given SQL statement, which may return multiple results,\n     * and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval. This array contains the names of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available.  The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * In some (uncommon) situations, a single SQL statement may return\n     * multiple result sets and/or update counts.  Normally you can ignore\n     * this unless you are (1) executing a stored procedure that you know may\n     * return multiple results or (2) you are dynamically executing an\n     * unknown SQL string.\n     * <P>\n     * The <code>execute</code> method executes an SQL statement and indicates the\n     * form of the first result.  You must then use the methods\n     * <code>getResultSet</code> or <code>getUpdateCount</code>\n     * to retrieve the result, and <code>getMoreResults</code> to\n     * move to any subsequent result(s).\n     *<p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     * @param sql any SQL statement\n     * @param columnNames an array of the names of the columns in the inserted\n     *        row that should be made available for retrieval by a call to the\n     *        method <code>getGeneratedKeys</code>\n     * @return <code>true</code> if the next result is a <code>ResultSet</code>\n     *         object; <code>false</code> if it is an update count or there\n     *         are no more results\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>,the\n     *          elements of the <code>String</code> array passed to this\n     *          method are not valid column names, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @see #getResultSet\n     * @see #getUpdateCount\n     * @see #getMoreResults\n     * @see #getGeneratedKeys\n     *\n     * @since 1.4\n     */\n    boolean execute(String sql, String columnNames[]) throws SQLException;\n\n   /**\n     * Retrieves the result set holdability for <code>ResultSet</code> objects\n     * generated by this <code>Statement</code> object.\n     *\n     * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     *\n     * @since 1.4\n     */\n    int getResultSetHoldability() throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Statement</code> object has been closed. A <code>Statement</code> is closed if the\n     * method close has been called on it, or if it is automatically closed.\n     * @return true if this <code>Statement</code> object is closed; false if it is still open\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    boolean isClosed() throws SQLException;\n\n        /**\n         * Requests that a <code>Statement</code> be pooled or not pooled.  The value\n         * specified is a hint to the statement pool implementation indicating\n         * whether the application wants the statement to be pooled.  It is up to\n         * the statement pool manager as to whether the hint is used.\n         * <p>\n         * The poolable value of a statement is applicable to both internal\n         * statement caches implemented by the driver and external statement caches\n         * implemented by application servers and other applications.\n         * <p>\n         * By default, a <code>Statement</code> is not poolable when created, and\n         * a <code>PreparedStatement</code> and <code>CallableStatement</code>\n         * are poolable when created.\n         *\n         * @param poolable              requests that the statement be pooled if true and\n         *                                              that the statement not be pooled if false\n         *\n         * @throws SQLException if this method is called on a closed\n         * <code>Statement</code>\n         *\n         * @since 1.6\n         */\n        void setPoolable(boolean poolable)\n                throws SQLException;\n\n        /**\n         * Returns a  value indicating whether the <code>Statement</code>\n         * is poolable or not.\n         *\n         * @return              <code>true</code> if the <code>Statement</code>\n         * is poolable; <code>false</code> otherwise\n         *\n         * @throws SQLException if this method is called on a closed\n         * <code>Statement</code>\n         *\n         * @since 1.6\n         *\n         * @see java.sql.Statement#setPoolable(boolean) setPoolable(boolean)\n         */\n        boolean isPoolable()\n                throws SQLException;\n\n    //--------------------------JDBC 4.1 -----------------------------\n\n    /**\n     * Specifies that this {@code Statement} will be closed when all its\n     * dependent result sets are closed. If execution of the {@code Statement}\n     * does not produce any result sets, this method has no effect.\n     * <p>\n     * <strong>Note:</strong> Multiple calls to {@code closeOnCompletion} do\n     * not toggle the effect on this {@code Statement}. However, a call to\n     * {@code closeOnCompletion} does effect both the subsequent execution of\n     * statements, and statements that currently have open, dependent,\n     * result sets.\n     *\n     * @throws SQLException if this method is called on a closed\n     * {@code Statement}\n     * @since 1.7\n     */\n    public void closeOnCompletion() throws SQLException;\n\n    /**\n     * Returns a value indicating whether this {@code Statement} will be\n     * closed when all its dependent result sets are closed.\n     * @return {@code true} if the {@code Statement} will be closed when all\n     * of its dependent result sets are closed; {@code false} otherwise\n     * @throws SQLException if this method is called on a closed\n     * {@code Statement}\n     * @since 1.7\n     */\n    public boolean isCloseOnCompletion() throws SQLException;\n\n\n    //--------------------------JDBC 4.2 -----------------------------\n\n    /**\n     *  Retrieves the current result as an update count; if the result\n     * is a <code>ResultSet</code> object or there are no more results, -1\n     *  is returned. This method should be called only once per result.\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     *<p>\n     * The default implementation will throw {@code UnsupportedOperationException}\n     *\n     * @return the current result as an update count; -1 if the current result\n     * is a <code>ResultSet</code> object or there are no more results\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #execute\n     * @since 1.8\n     */\n    default long getLargeUpdateCount() throws SQLException {\n        throw new UnsupportedOperationException(\"getLargeUpdateCount not implemented\");\n    }\n\n    /**\n     * Sets the limit for the maximum number of rows that any\n     * <code>ResultSet</code> object  generated by this <code>Statement</code>\n     * object can contain to the given number.\n     * If the limit is exceeded, the excess\n     * rows are silently dropped.\n     * <p>\n     * This method should be used when the row limit may exceed\n     * {@link Integer#MAX_VALUE}.\n     *<p>\n     * The default implementation will throw {@code UnsupportedOperationException}\n     *\n     * @param max the new max rows limit; zero means there is no limit\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>\n     *            or the condition {@code max >= 0} is not satisfied\n     * @see #getMaxRows\n     * @since 1.8\n     */\n    default void setLargeMaxRows(long max) throws SQLException {\n        throw new UnsupportedOperationException(\"setLargeMaxRows not implemented\");\n    }\n\n    /**\n     * Retrieves the maximum number of rows that a\n     * <code>ResultSet</code> object produced by this\n     * <code>Statement</code> object can contain.  If this limit is exceeded,\n     * the excess rows are silently dropped.\n     * <p>\n     * This method should be used when the returned row limit may exceed\n     * {@link Integer#MAX_VALUE}.\n     *<p>\n     * The default implementation will return {@code 0}\n     *\n     * @return the current maximum number of rows for a <code>ResultSet</code>\n     *         object produced by this <code>Statement</code> object;\n     *         zero means there is no limit\n     * @exception SQLException if a database access error occurs or\n     * this method is called on a closed <code>Statement</code>\n     * @see #setMaxRows\n     * @since 1.8\n     */\n    default long getLargeMaxRows() throws SQLException {\n        return 0;\n    }\n\n    /**\n     * Submits a batch of commands to the database for execution and\n     * if all commands execute successfully, returns an array of update counts.\n     * The <code>long</code> elements of the array that is returned are ordered\n     * to correspond to the commands in the batch, which are ordered\n     * according to the order in which they were added to the batch.\n     * The elements in the array returned by the method {@code executeLargeBatch}\n     * may be one of the following:\n     * <OL>\n     * <LI>A number greater than or equal to zero -- indicates that the\n     * command was processed successfully and is an update count giving the\n     * number of rows in the database that were affected by the command's\n     * execution\n     * <LI>A value of <code>SUCCESS_NO_INFO</code> -- indicates that the command was\n     * processed successfully but that the number of rows affected is\n     * unknown\n     * <P>\n     * If one of the commands in a batch update fails to execute properly,\n     * this method throws a <code>BatchUpdateException</code>, and a JDBC\n     * driver may or may not continue to process the remaining commands in\n     * the batch.  However, the driver's behavior must be consistent with a\n     * particular DBMS, either always continuing to process commands or never\n     * continuing to process commands.  If the driver continues processing\n     * after a failure, the array returned by the method\n     * <code>BatchUpdateException.getLargeUpdateCounts</code>\n     * will contain as many elements as there are commands in the batch, and\n     * at least one of the elements will be the following:\n     *\n     * <LI>A value of <code>EXECUTE_FAILED</code> -- indicates that the command failed\n     * to execute successfully and occurs only if a driver continues to\n     * process commands after a command fails\n     * </OL>\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     *<p>\n     * The default implementation will throw {@code UnsupportedOperationException}\n     *\n     * @return an array of update counts containing one element for each\n     * command in the batch.  The elements of the array are ordered according\n     * to the order in which commands were added to the batch.\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code> or the\n     * driver does not support batch statements. Throws {@link BatchUpdateException}\n     * (a subclass of <code>SQLException</code>) if one of the commands sent to the\n     * database fails to execute properly or attempts to return a result set.\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     *\n     * @see #addBatch\n     * @see DatabaseMetaData#supportsBatchUpdates\n     * @since 1.8\n     */\n    default long[] executeLargeBatch() throws SQLException {\n        throw new UnsupportedOperationException(\"executeLargeBatch not implemented\");\n    }\n\n    /**\n     * Executes the given SQL statement, which may be an <code>INSERT</code>,\n     * <code>UPDATE</code>, or <code>DELETE</code> statement or an\n     * SQL statement that returns nothing, such as an SQL DDL statement.\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     * <p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     *<p>\n     * The default implementation will throw {@code UnsupportedOperationException}\n     *\n     * @param sql an SQL Data Manipulation Language (DML) statement,\n     * such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @return either (1) the row count for SQL Data Manipulation Language\n     * (DML) statements or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the given\n     * SQL statement produces a <code>ResultSet</code> object, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.8\n     */\n    default long executeLargeUpdate(String sql) throws SQLException {\n        throw new UnsupportedOperationException(\"executeLargeUpdate not implemented\");\n    }\n\n    /**\n     * Executes the given SQL statement and signals the driver with the\n     * given flag about whether the\n     * auto-generated keys produced by this <code>Statement</code> object\n     * should be made available for retrieval.  The driver will ignore the\n     * flag if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     * <p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     *<p>\n     * The default implementation will throw {@code SQLFeatureNotSupportedException}\n     *\n     * @param sql an SQL Data Manipulation Language (DML) statement,\n     * such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @param autoGeneratedKeys a flag indicating whether auto-generated keys\n     *        should be made available for retrieval;\n     *         one of the following constants:\n     *         <code>Statement.RETURN_GENERATED_KEYS</code>\n     *         <code>Statement.NO_GENERATED_KEYS</code>\n     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements\n     *         or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     *  this method is called on a closed <code>Statement</code>, the given\n     *            SQL statement returns a <code>ResultSet</code> object,\n     *            the given constant is not one of those allowed, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.8\n     */\n    default long executeLargeUpdate(String sql, int autoGeneratedKeys)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"executeLargeUpdate not implemented\");\n    }\n\n    /**\n     * Executes the given SQL statement and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval.   This array contains the indexes of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available. The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     * <p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     *<p>\n     * The default implementation will throw {@code SQLFeatureNotSupportedException}\n     *\n     * @param sql an SQL Data Manipulation Language (DML) statement,\n     * such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     *\n     * @param columnIndexes an array of column indexes indicating the columns\n     *        that should be returned from the inserted row\n     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements\n     *         or (2) 0 for SQL statements that return nothing\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called on a closed <code>Statement</code>, the SQL\n     * statement returns a <code>ResultSet</code> object,the second argument\n     * supplied to this method is not an\n     * <code>int</code> array whose elements are valid column indexes, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.8\n     */\n    default long executeLargeUpdate(String sql, int columnIndexes[]) throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"executeLargeUpdate not implemented\");\n    }\n\n    /**\n     * Executes the given SQL statement and signals the driver that the\n     * auto-generated keys indicated in the given array should be made available\n     * for retrieval.   This array contains the names of the columns in the\n     * target table that contain the auto-generated keys that should be made\n     * available. The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <p>\n     * This method should be used when the returned row count may exceed\n     * {@link Integer#MAX_VALUE}.\n     * <p>\n     * <strong>Note:</strong>This method cannot be called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>.\n     *<p>\n     * The default implementation will throw {@code SQLFeatureNotSupportedException}\n     *\n     * @param sql an SQL Data Manipulation Language (DML) statement,\n     * such as <code>INSERT</code>, <code>UPDATE</code> or\n     * <code>DELETE</code>; or an SQL statement that returns nothing,\n     * such as a DDL statement.\n     * @param columnNames an array of the names of the columns that should be\n     *        returned from the inserted row\n     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>,\n     *         or <code>DELETE</code> statements, or 0 for SQL statements\n     *         that return nothing\n     * @exception SQLException if a database access error occurs,\n     *  this method is called on a closed <code>Statement</code>, the SQL\n     *            statement returns a <code>ResultSet</code> object, the\n     *            second argument supplied to this method is not a <code>String</code> array\n     *            whose elements are valid column names, the method is called on a\n     * <code>PreparedStatement</code> or <code>CallableStatement</code>\n     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method\n     * @throws SQLTimeoutException when the driver has determined that the\n     * timeout value that was specified by the {@code setQueryTimeout}\n     * method has been exceeded and has at least attempted to cancel\n     * the currently running {@code Statement}\n     * @since 1.8\n     */\n    default long executeLargeUpdate(String sql, String columnNames[])\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"executeLargeUpdate not implemented\");\n    }\n\n    // JDBC 4.3\n\n    /**\n     * Returns a {@code String} enclosed in single quotes. Any occurrence of a\n     * single quote within the string will be replaced by two single quotes.\n     *\n     * <blockquote>\n     * <table class=\"striped\">\n     * <caption>Examples of the conversion:</caption>\n     * <thead>\n     * <tr><th scope=\"col\">Value</th><th scope=\"col\">Result</th></tr>\n     * </thead>\n     * <tbody style=\"text-align:center\">\n     * <tr> <th scope=\"row\">Hello</th> <td>'Hello'</td> </tr>\n     * <tr> <th scope=\"row\">G'Day</th> <td>'G''Day'</td> </tr>\n     * <tr> <th scope=\"row\">'G''Day'</th>\n     * <td>'''G''''Day'''</td> </tr>\n     * <tr> <th scope=\"row\">I'''M</th> <td>'I''''''M'</td>\n     * </tr>\n     *\n     * </tbody>\n     * </table>\n     * </blockquote>\n     * @implNote\n     * JDBC driver implementations may need to provide their own implementation\n     * of this method in order to meet the requirements of the underlying\n     * datasource.\n     * @param val a character string\n     * @return A string enclosed by single quotes with every single quote\n     * converted to two single quotes\n     * @throws NullPointerException if val is {@code null}\n     * @throws SQLException if a database access error occurs\n     *\n     * @since 9\n     */\n     default String enquoteLiteral(String val)  throws SQLException {\n         return \"'\" + val.replace(\"'\", \"''\") +  \"'\";\n    }\n\n\n     /**\n     * Returns a SQL identifier. If {@code identifier} is a simple SQL identifier:\n     * <ul>\n     * <li>Return the original value if {@code alwaysQuote} is\n     * {@code false}</li>\n     * <li>Return a delimited identifier if {@code alwaysQuote} is\n     * {@code true}</li>\n     * </ul>\n     *\n     * If {@code identifier} is not a simple SQL identifier, {@code identifier} will be\n     * enclosed in double quotes if not already present. If the datasource does\n     * not support double quotes for delimited identifiers, the\n     * identifier should be enclosed by the string returned from\n     * {@link DatabaseMetaData#getIdentifierQuoteString}.  If the datasource\n     * does not support delimited identifiers, a\n     * {@code SQLFeatureNotSupportedException} should be thrown.\n     * <p>\n     * A {@code SQLException} will be thrown if {@code identifier} contains any\n     * characters invalid in a delimited identifier or the identifier length is\n     * invalid for the datasource.\n     *\n     * @implSpec\n     * The default implementation uses the following criteria to\n     * determine a valid simple SQL identifier:\n     * <ul>\n     * <li>The string is not enclosed in double quotes</li>\n     * <li>The first character is an alphabetic character from a through z, or\n     * from A through Z</li>\n     * <li>The name only contains alphanumeric characters or the character \"_\"</li>\n     * </ul>\n     *\n     * The default implementation will throw a {@code SQLException} if:\n     * <ul>\n     * <li>{@code identifier} contains a {@code null} character or double quote and is not\n     * a simple SQL identifier.</li>\n     * <li>The length of {@code identifier} is less than 1 or greater than 128 characters\n     * </ul>\n     * <blockquote>\n     * <table class=\"striped\" >\n     * <caption>Examples of the conversion:</caption>\n     * <thead>\n     * <tr>\n     * <th scope=\"col\">identifier</th>\n     * <th scope=\"col\">alwaysQuote</th>\n     * <th scope=\"col\">Result</th></tr>\n     * </thead>\n     * <tbody>\n     * <tr>\n     * <th scope=\"row\">Hello</th>\n     * <td>false</td>\n     * <td>Hello</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">Hello</th>\n     * <td>true</td>\n     * <td>\"Hello\"</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">G'Day</th>\n     * <td>false</td>\n     * <td>\"G'Day\"</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">\"Bruce Wayne\"</th>\n     * <td>false</td>\n     * <td>\"Bruce Wayne\"</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">\"Bruce Wayne\"</th>\n     * <td>true</td>\n     * <td>\"Bruce Wayne\"</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">GoodDay$</th>\n     * <td>false</td>\n     * <td>\"GoodDay$\"</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">Hello\"World</th>\n     * <td>false</td>\n     * <td>SQLException</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">\"Hello\"World\"</th>\n     * <td>false</td>\n     * <td>SQLException</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * </blockquote>\n     * @implNote\n     * JDBC driver implementations may need to provide their own implementation\n     * of this method in order to meet the requirements of the underlying\n     * datasource.\n     * @param identifier a SQL identifier\n     * @param alwaysQuote indicates if a simple SQL identifier should be\n     * returned as a quoted identifier\n     * @return A simple SQL identifier or a delimited identifier\n     * @throws SQLException if identifier is not a valid identifier\n     * @throws SQLFeatureNotSupportedException if the datasource does not support\n     * delimited identifiers\n     * @throws NullPointerException if identifier is {@code null}\n     *\n     * @since 9\n     */\n    default String enquoteIdentifier(String identifier, boolean alwaysQuote) throws SQLException {\n        int len = identifier.length();\n        if (len < 1 || len > 128) {\n            throw new SQLException(\"Invalid name\");\n        }\n        if (Pattern.compile(\"[\\\\p{Alpha}][\\\\p{Alnum}_]*\").matcher(identifier).matches()) {\n            return alwaysQuote ?  \"\\\"\" + identifier + \"\\\"\" : identifier;\n        }\n        if (identifier.matches(\"^\\\".+\\\"$\")) {\n            identifier = identifier.substring(1, len - 1);\n        }\n        if (Pattern.compile(\"[^\\u0000\\\"]+\").matcher(identifier).matches()) {\n            return \"\\\"\" + identifier + \"\\\"\";\n        } else {\n            throw new SQLException(\"Invalid name\");\n        }\n    }\n\n    /**\n     * Retrieves whether {@code identifier} is a simple SQL identifier.\n     *\n     * @implSpec The default implementation uses the following criteria to\n     * determine a valid simple SQL identifier:\n     * <ul>\n     * <li>The string is not enclosed in double quotes</li>\n     * <li>The first character is an alphabetic character from a through z, or\n     * from A through Z</li>\n     * <li>The string only contains alphanumeric characters or the character\n     * \"_\"</li>\n     * <li>The string is between 1 and 128 characters in length inclusive</li>\n     * </ul>\n     *\n     * <blockquote>\n     * <table class=\"striped\" >\n     * <caption>Examples of the conversion:</caption>\n     * <thead>\n     * <tr>\n     * <th scope=\"col\">identifier</th>\n     * <th scope=\"col\">Simple Identifier</th>\n     * </thead>\n     *\n     * <tbody>\n     * <tr>\n     * <th scope=\"row\">Hello</th>\n     * <td>true</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">G'Day</th>\n     * <td>false</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">\"Bruce Wayne\"</th>\n     * <td>false</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">GoodDay$</th>\n     * <td>false</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">Hello\"World</th>\n     * <td>false</td>\n     * </tr>\n     * <tr>\n     * <th scope=\"row\">\"Hello\"World\"</th>\n     * <td>false</td>\n     * </tr>\n     * </tbody>\n     * </table>\n     * </blockquote>\n     * @implNote JDBC driver implementations may need to provide their own\n     * implementation of this method in order to meet the requirements of the\n     * underlying datasource.\n     * @param identifier a SQL identifier\n     * @return  true if  a simple SQL identifier, false otherwise\n     * @throws NullPointerException if identifier is {@code null}\n     * @throws SQLException if a database access error occurs\n     *\n     * @since 9\n     */\n    default boolean isSimpleIdentifier(String identifier) throws SQLException {\n        int len = identifier.length();\n        return len >= 1 && len <= 128\n                && Pattern.compile(\"[\\\\p{Alpha}][\\\\p{Alnum}_]*\").matcher(identifier).matches();\n    }\n\n    /**\n    * Returns a {@code String} representing a National Character Set Literal\n    * enclosed in single quotes and prefixed with a upper case letter N.\n    * Any occurrence of a single quote within the string will be replaced\n    * by two single quotes.\n    *\n    * <blockquote>\n    * <table class=\"striped\">\n    * <caption>Examples of the conversion:</caption>\n    * <thead>\n    * <tr>\n    * <th scope=\"col\">Value</th>\n    * <th scope=\"col\">Result</th>\n    * </tr>\n    * </thead>\n    * <tbody>\n    * <tr> <th scope=\"row\">Hello</th> <td>N'Hello'</td> </tr>\n    * <tr> <th scope=\"row\">G'Day</th> <td>N'G''Day'</td> </tr>\n    * <tr> <th scope=\"row\">'G''Day'</th>\n    * <td>N'''G''''Day'''</td> </tr>\n    * <tr> <th scope=\"row\">I'''M</th> <td>N'I''''''M'</td>\n    * <tr> <th scope=\"row\">N'Hello'</th> <td>N'N''Hello'''</td> </tr>\n    *\n    * </tbody>\n    * </table>\n    * </blockquote>\n    * @implNote\n    * JDBC driver implementations may need to provide their own implementation\n    * of this method in order to meet the requirements of the underlying\n    * datasource. An implementation of enquoteNCharLiteral may accept a different\n    * set of characters than that accepted by the same drivers implementation of\n    * enquoteLiteral.\n    * @param val a character string\n    * @return the result of replacing every single quote character in the\n    * argument by two single quote characters where this entire result is\n    * then prefixed with 'N'.\n    * @throws NullPointerException if val is {@code null}\n    * @throws SQLException if a database access error occurs\n    *\n    * @since 9\n    */\n    default String enquoteNCharLiteral(String val)  throws SQLException {\n        return \"N'\" + val.replace(\"'\", \"''\") +  \"'\";\n   }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Statement.java"}})[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":60,"character":58}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //statement.executeUpdate("INSERT INTO project0 (todoList) values ("+arrBuff(x)+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":22}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(arrBuff(x))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol println[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":49}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println(query)[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":49}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":49}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":66})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":48}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":67})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":59,"character":46}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol numbers[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol numbers[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol enter[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":26}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":69})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":31}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":70})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":40}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":80}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol values[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":72,"character":27}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ase[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":72,"character":26}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ase[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":58}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":28}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":76})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":39}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ase[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":77})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":78})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":79})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exception[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":76,"character":33}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":81})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":76,"character":33}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     println("Please only enter numbers 1 - 4")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Please[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Please[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":99}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":31}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":84})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":85})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":86})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":30}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":64,"character":62}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val statement = connection.createStatement()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":88})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":65,"character":62}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todolist) Values ("+quer")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":89})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":65,"character":61}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todolist) Values ("+quer")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":90})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":41}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol createStatement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exception[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":66,"character":21}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val resultSet = statement.executeQuery("SELECT * FROM project0") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol al[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":31}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol print[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":65,"character":46}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todolist) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":73,"character":27}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":96})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":73,"character":26}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol connection[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol connection[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":72,"character":38}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exception[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":37}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":100})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":32}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":101})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":28}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exception[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ase[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exception[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":65,"character":107}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO orders (OrderID, CustomerID, price) Values (401, 100, 10.5)")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":103})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":82}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                         print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol 100[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol 2[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":61,"character":20}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var connection:Connection = null[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol va[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             }[0m
[0m[[0m[0minfo[0m] [0m[0mSymbol not found in definition request {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":71,"character":62}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     case e: Exception => e.printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol printStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":73,"character":36}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol close[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java","languageId":"java","version":1,"text":"/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.sql;\n\nimport java.util.Properties;\nimport java.util.concurrent.Executor;\n\n/**\n * <P>A connection (session) with a specific\n * database. SQL statements are executed and results are returned\n * within the context of a connection.\n * <P>\n * A <code>Connection</code> object's database is able to provide information\n * describing its tables, its supported SQL grammar, its stored\n * procedures, the capabilities of this connection, and so on. This\n * information is obtained with the <code>getMetaData</code> method.\n *\n * <P><B>Note:</B> When configuring a <code>Connection</code>, JDBC applications\n *  should use the appropriate <code>Connection</code> method such as\n *  <code>setAutoCommit</code> or <code>setTransactionIsolation</code>.\n *  Applications should not invoke SQL commands directly to change the connection's\n *   configuration when there is a JDBC method available.  By default a <code>Connection</code> object is in\n * auto-commit mode, which means that it automatically commits changes\n * after executing each statement. If auto-commit mode has been\n * disabled, the method <code>commit</code> must be called explicitly in\n * order to commit changes; otherwise, database changes will not be saved.\n * <P>\n * A new <code>Connection</code> object created using the JDBC 2.1 core API\n * has an initially empty type map associated with it. A user may enter a\n * custom mapping for a UDT in this type map.\n * When a UDT is retrieved from a data source with the\n * method <code>ResultSet.getObject</code>, the <code>getObject</code> method\n * will check the connection's type map to see if there is an entry for that\n * UDT.  If so, the <code>getObject</code> method will map the UDT to the\n * class indicated.  If there is no entry, the UDT will be mapped using the\n * standard mapping.\n * <p>\n * A user may create a new type map, which is a <code>java.util.Map</code>\n * object, make an entry in it, and pass it to the <code>java.sql</code>\n * methods that can perform custom mapping.  In this case, the method\n * will use the given type map instead of the one associated with\n * the connection.\n * <p>\n * For example, the following code fragment specifies that the SQL\n * type <code>ATHLETES</code> will be mapped to the class\n * <code>Athletes</code> in the Java programming language.\n * The code fragment retrieves the type map for the <code>Connection\n * </code> object <code>con</code>, inserts the entry into it, and then sets\n * the type map with the new entry as the connection's type map.\n * <pre>\n *      java.util.Map map = con.getTypeMap();\n *      map.put(\"mySchemaName.ATHLETES\", Class.forName(\"Athletes\"));\n *      con.setTypeMap(map);\n * </pre>\n *\n * @see DriverManager#getConnection\n * @see Statement\n * @see ResultSet\n * @see DatabaseMetaData\n * @since 1.1\n */\npublic interface Connection  extends Wrapper, AutoCloseable {\n\n    /**\n     * Creates a <code>Statement</code> object for sending\n     * SQL statements to the database.\n     * SQL statements without parameters are normally\n     * executed using <code>Statement</code> objects. If the same SQL statement\n     * is executed many times, it may be more efficient to use a\n     * <code>PreparedStatement</code> object.\n     * <P>\n     * Result sets created using the returned <code>Statement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @return a new default <code>Statement</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    Statement createStatement() throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object for sending\n     * parameterized SQL statements to the database.\n     * <P>\n     * A SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     *\n     * <P><B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain <code>SQLException</code> objects.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     * parameter placeholders\n     * @return a new default <code>PreparedStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    PreparedStatement prepareStatement(String sql)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object for calling\n     * database stored procedures.\n     * The <code>CallableStatement</code> object provides\n     * methods for setting up its IN and OUT parameters, and\n     * methods for executing the call to a stored procedure.\n     *\n     * <P><B>Note:</B> This method is optimized for handling stored\n     * procedure call statements. Some drivers may send the call\n     * statement to the database when the method <code>prepareCall</code>\n     * is done; others\n     * may wait until the <code>CallableStatement</code> object\n     * is executed. This has no\n     * direct effect on users; however, it does affect which method\n     * throws certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>CallableStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders. Typically this statement is specified using JDBC\n     * call escape syntax.\n     * @return a new default <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    CallableStatement prepareCall(String sql) throws SQLException;\n\n    /**\n     * Converts the given SQL statement into the system's native SQL grammar.\n     * A driver may convert the JDBC SQL grammar into its system's\n     * native SQL grammar prior to sending it. This method returns the\n     * native form of the statement that the driver would have sent.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders\n     * @return the native form of this statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    String nativeSQL(String sql) throws SQLException;\n\n    /**\n     * Sets this connection's auto-commit mode to the given state.\n     * If a connection is in auto-commit mode, then all its SQL\n     * statements will be executed and committed as individual\n     * transactions.  Otherwise, its SQL statements are grouped into\n     * transactions that are terminated by a call to either\n     * the method <code>commit</code> or the method <code>rollback</code>.\n     * By default, new connections are in auto-commit\n     * mode.\n     * <P>\n     * The commit occurs when the statement completes. The time when the statement\n     * completes depends on the type of SQL Statement:\n     * <ul>\n     * <li>For DML statements, such as Insert, Update or Delete, and DDL statements,\n     * the statement is complete as soon as it has finished executing.\n     * <li>For Select statements, the statement is complete when the associated result\n     * set is closed.\n     * <li>For <code>CallableStatement</code> objects or for statements that return\n     * multiple results, the statement is complete\n     * when all of the associated result sets have been closed, and all update\n     * counts and output parameters have been retrieved.\n     *</ul>\n     * <P>\n     * <B>NOTE:</B>  If this method is called during a transaction and the\n     * auto-commit mode is changed, the transaction is committed.  If\n     * <code>setAutoCommit</code> is called and the auto-commit mode is\n     * not changed, the call is a no-op.\n     *\n     * @param autoCommit <code>true</code> to enable auto-commit mode;\n     *         <code>false</code> to disable it\n     * @exception SQLException if a database access error occurs,\n     *  setAutoCommit(true) is called while participating in a distributed transaction,\n     * or this method is called on a closed connection\n     * @see #getAutoCommit\n     */\n    void setAutoCommit(boolean autoCommit) throws SQLException;\n\n    /**\n     * Retrieves the current auto-commit mode for this <code>Connection</code>\n     * object.\n     *\n     * @return the current state of this <code>Connection</code> object's\n     *         auto-commit mode\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setAutoCommit\n     */\n    boolean getAutoCommit() throws SQLException;\n\n    /**\n     * Makes all changes made since the previous\n     * commit/rollback permanent and releases any database locks\n     * currently held by this <code>Connection</code> object.\n     * This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * if this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void commit() throws SQLException;\n\n    /**\n     * Undoes all changes made in the current transaction\n     * and releases any database locks currently held\n     * by this <code>Connection</code> object. This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void rollback() throws SQLException;\n\n    /**\n     * Releases this <code>Connection</code> object's database and JDBC resources\n     * immediately instead of waiting for them to be automatically released.\n     * <P>\n     * Calling the method <code>close</code> on a <code>Connection</code>\n     * object that is already closed is a no-op.\n     * <P>\n     * It is <b>strongly recommended</b> that an application explicitly\n     * commits or rolls back an active transaction prior to calling the\n     * <code>close</code> method.  If the <code>close</code> method is called\n     * and there is an active transaction, the results are implementation-defined.\n     *\n     * @exception SQLException if a database access error occurs\n     */\n    void close() throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code> object has been\n     * closed.  A connection is closed if the method <code>close</code>\n     * has been called on it or if certain fatal errors have occurred.\n     * This method is guaranteed to return <code>true</code> only when\n     * it is called after the method <code>Connection.close</code> has\n     * been called.\n     * <P>\n     * This method generally cannot be called to determine whether a\n     * connection to a database is valid or invalid.  A typical client\n     * can determine that a connection is invalid by catching any\n     * exceptions that might be thrown when an operation is attempted.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is closed; <code>false</code> if it is still open\n     * @exception SQLException if a database access error occurs\n     */\n    boolean isClosed() throws SQLException;\n\n    //======================================================================\n    // Advanced features:\n\n    /**\n     * Retrieves a <code>DatabaseMetaData</code> object that contains\n     * metadata about the database to which this\n     * <code>Connection</code> object represents a connection.\n     * The metadata includes information about the database's\n     * tables, its supported SQL grammar, its stored\n     * procedures, the capabilities of this connection, and so on.\n     *\n     * @return a <code>DatabaseMetaData</code> object for this\n     *         <code>Connection</code> object\n     * @exception  SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    DatabaseMetaData getMetaData() throws SQLException;\n\n    /**\n     * Puts this connection in read-only mode as a hint to the driver to enable\n     * database optimizations.\n     *\n     * <P><B>Note:</B> This method cannot be called during a transaction.\n     *\n     * @param readOnly <code>true</code> enables read-only mode;\n     *        <code>false</code> disables it\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or this\n     *            method is called during a transaction\n     */\n    void setReadOnly(boolean readOnly) throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code>\n     * object is in read-only mode.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is read-only; <code>false</code> otherwise\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    boolean isReadOnly() throws SQLException;\n\n    /**\n     * Sets the given catalog name in order to select\n     * a subspace of this <code>Connection</code> object's database\n     * in which to work.\n     * <P>\n     * If the driver does not support catalogs, it will\n     * silently ignore this request.\n     * <p>\n     * Calling {@code setCatalog} has no effect on previously created or prepared\n     * {@code Statement} objects. It is implementation defined whether a DBMS\n     * prepare operation takes place immediately when the {@code Connection}\n     * method {@code prepareStatement} or {@code prepareCall} is invoked.\n     * For maximum portability, {@code setCatalog} should be called before a\n     * {@code Statement} is created or prepared.\n     *\n     * @param catalog the name of a catalog (subspace in this\n     *        <code>Connection</code> object's database) in which to work\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #getCatalog\n     */\n    void setCatalog(String catalog) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current catalog name.\n     *\n     * @return the current catalog name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setCatalog\n     */\n    String getCatalog() throws SQLException;\n\n    /**\n     * A constant indicating that transactions are not supported.\n     */\n    int TRANSACTION_NONE             = 0;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads can occur.\n     * This level allows a row changed by one transaction to be read\n     * by another transaction before any changes in that row have been\n     * committed (a \"dirty read\").  If any of the changes are rolled back,\n     * the second transaction will have retrieved an invalid row.\n     */\n    int TRANSACTION_READ_UNCOMMITTED = 1;\n\n    /**\n     * A constant indicating that\n     * dirty reads are prevented; non-repeatable reads and phantom\n     * reads can occur.  This level only prohibits a transaction\n     * from reading a row with uncommitted changes in it.\n     */\n    int TRANSACTION_READ_COMMITTED   = 2;\n\n    /**\n     * A constant indicating that\n     * dirty reads and non-repeatable reads are prevented; phantom\n     * reads can occur.  This level prohibits a transaction from\n     * reading a row with uncommitted changes in it, and it also\n     * prohibits the situation where one transaction reads a row,\n     * a second transaction alters the row, and the first transaction\n     * rereads the row, getting different values the second time\n     * (a \"non-repeatable read\").\n     */\n    int TRANSACTION_REPEATABLE_READ  = 4;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads are prevented.\n     * This level includes the prohibitions in\n     * <code>TRANSACTION_REPEATABLE_READ</code> and further prohibits the\n     * situation where one transaction reads all rows that satisfy\n     * a <code>WHERE</code> condition, a second transaction inserts a row that\n     * satisfies that <code>WHERE</code> condition, and the first transaction\n     * rereads for the same condition, retrieving the additional\n     * \"phantom\" row in the second read.\n     */\n    int TRANSACTION_SERIALIZABLE     = 8;\n\n    /**\n     * Attempts to change the transaction isolation level for this\n     * <code>Connection</code> object to the one given.\n     * The constants defined in the interface <code>Connection</code>\n     * are the possible transaction isolation levels.\n     * <P>\n     * <B>Note:</B> If this method is called during a transaction, the result\n     * is implementation-defined.\n     *\n     * @param level one of the following <code>Connection</code> constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>, or\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>.\n     *        (Note that <code>Connection.TRANSACTION_NONE</code> cannot be used\n     *        because it specifies that transactions are not supported.)\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameter is not one of the <code>Connection</code>\n     *            constants\n     * @see DatabaseMetaData#supportsTransactionIsolationLevel\n     * @see #getTransactionIsolation\n     */\n    void setTransactionIsolation(int level) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current\n     * transaction isolation level.\n     *\n     * @return the current transaction isolation level, which will be one\n     *         of the following constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>,\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>, or\n     *        <code>Connection.TRANSACTION_NONE</code>.\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setTransactionIsolation\n     */\n    int getTransactionIsolation() throws SQLException;\n\n    /**\n     * Retrieves the first warning reported by calls on this\n     * <code>Connection</code> object.  If there is more than one\n     * warning, subsequent warnings will be chained to the first one\n     * and can be retrieved by calling the method\n     * <code>SQLWarning.getNextWarning</code> on the warning\n     * that was retrieved previously.\n     * <P>\n     * This method may not be\n     * called on a closed connection; doing so will cause an\n     * <code>SQLException</code> to be thrown.\n     *\n     * <P><B>Note:</B> Subsequent warnings will be chained to this\n     * SQLWarning.\n     *\n     * @return the first <code>SQLWarning</code> object or <code>null</code>\n     *         if there are none\n     * @exception SQLException if a database access error occurs or\n     *            this method is called on a closed connection\n     * @see SQLWarning\n     */\n    SQLWarning getWarnings() throws SQLException;\n\n    /**\n     * Clears all warnings reported for this <code>Connection</code> object.\n     * After a call to this method, the method <code>getWarnings</code>\n     * returns <code>null</code> until a new warning is\n     * reported for this <code>Connection</code> object.\n     *\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    void clearWarnings() throws SQLException;\n\n\n    //--------------------------JDBC 2.0-----------------------------\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param resultSetType a result set type; one of\n     *        <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *        <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *        <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type and\n     *         concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     *\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new PreparedStatement object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this method\n     * is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency) throws SQLException;\n\n    /**\n     * Retrieves the <code>Map</code> object associated with this\n     * <code>Connection</code> object.\n     * Unless the application has added an entry, the type map returned\n     * will be empty.\n     * <p>\n     * You must invoke <code>setTypeMap</code> after making changes to the\n     * <code>Map</code> object returned from\n     *  <code>getTypeMap</code> as a JDBC driver may create an internal\n     * copy of the <code>Map</code> object passed to <code>setTypeMap</code>:\n     *\n     * <pre>\n     *      Map&lt;String,Class&lt;?&gt;&gt; myMap = con.getTypeMap();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @return the <code>java.util.Map</code> object associated\n     *         with this <code>Connection</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #setTypeMap\n     */\n    java.util.Map<String,Class<?>> getTypeMap() throws SQLException;\n\n    /**\n     * Installs the given <code>TypeMap</code> object as the type map for\n     * this <code>Connection</code> object.  The type map will be used for the\n     * custom mapping of SQL structured types and distinct types.\n     * <p>\n     * You must set the values for the <code>TypeMap</code> prior to\n     * callng <code>setMap</code> as a JDBC driver may create an internal copy\n     * of the <code>TypeMap</code>:\n     *\n     * <pre>\n     *      Map myMap&lt;String,Class&lt;?&gt;&gt; = new HashMap&lt;String,Class&lt;?&gt;&gt;();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @param map the <code>java.util.Map</code> object to install\n     *        as the replacement for this <code>Connection</code>\n     *        object's default type map\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection or\n     *        the given parameter is not a <code>java.util.Map</code>\n     *        object\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #getTypeMap\n     */\n    void setTypeMap(java.util.Map<String,Class<?>> map) throws SQLException;\n\n    //--------------------------JDBC 3.0-----------------------------\n\n\n    /**\n     * Changes the default holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object to the given\n     * holdability.  The default holdability of <code>ResultSet</code> objects\n     * can be determined by invoking\n     * {@link DatabaseMetaData#getResultSetHoldability}.\n     *\n     * @param holdability a <code>ResultSet</code> holdability constant; one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access occurs, this method is called\n     * on a closed connection, or the given parameter\n     *         is not a <code>ResultSet</code> constant indicating holdability\n     * @exception SQLFeatureNotSupportedException if the given holdability is not supported\n     * @see #getHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    void setHoldability(int holdability) throws SQLException;\n\n    /**\n     * Retrieves the current holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object.\n     *\n     * @return the holdability, one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    int getHoldability() throws SQLException;\n\n    /**\n     * Creates an unnamed savepoint in the current transaction and\n     * returns the new <code>Savepoint</code> object that represents it.\n     *\n     *<p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint() throws SQLException;\n\n    /**\n     * Creates a savepoint with the given name in the current transaction\n     * and returns the new <code>Savepoint</code> object that represents it.\n     *\n     * <p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @param name a <code>String</code> containing the name of the savepoint\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n          * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint(String name) throws SQLException;\n\n    /**\n     * Undoes all changes made after the given <code>Savepoint</code> object\n     * was set.\n     * <P>\n     * This method should be used only when auto-commit has been disabled.\n     *\n     * @param savepoint the <code>Savepoint</code> object to roll back to\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection,\n     *            the <code>Savepoint</code> object is no longer valid,\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @see #rollback\n     * @since 1.4\n     */\n    void rollback(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Removes the specified <code>Savepoint</code>  and subsequent <code>Savepoint</code> objects from the current\n     * transaction. Any reference to the savepoint after it have been removed\n     * will cause an <code>SQLException</code> to be thrown.\n     *\n     * @param savepoint the <code>Savepoint</code> object to be removed\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or\n     *            the given <code>Savepoint</code> object is not a valid\n     *            savepoint in the current transaction\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.4\n     */\n    void releaseSavepoint(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency,\n                              int resultSetHoldability) throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * <P>\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency, int resultSetHoldability)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type, result set concurrency type and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>CallableStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency,\n                                  int resultSetHoldability) throws SQLException;\n\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object that has\n     * the capability to retrieve auto-generated keys. The given constant\n     * tells the driver whether it should make auto-generated keys\n     * available for retrieval.  This parameter is ignored if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param autoGeneratedKeys a flag indicating whether auto-generated keys\n     *        should be returned; one of\n     *        <code>Statement.RETURN_GENERATED_KEYS</code> or\n     *        <code>Statement.NO_GENERATED_KEYS</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will have the capability of\n     *         returning auto-generated keys\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection\n     *         or the given parameter is not a <code>Statement</code>\n     *         constant indicating whether auto-generated keys should be\n     *         returned\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the indexes of the columns in the target\n     * table that contain the auto-generated keys that should be made\n     * available.  The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnIndexes an array of column indexes indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         indexes\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int columnIndexes[])\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the names of the columns in the target\n     * table that contain the auto-generated keys that should be returned.\n     * The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnNames an array of column names indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         names\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, String columnNames[])\n        throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Clob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of\n     * the <code>Clob</code> interface may be used to add data to the <code>Clob</code>.\n     * @return An object that implements the <code>Clob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Clob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Clob createClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Blob</code> interface. The object\n     * returned initially contains no data.  The <code>setBinaryStream</code> and\n     * <code>setBytes</code> methods of the <code>Blob</code> interface may be used to add data to\n     * the <code>Blob</code>.\n     * @return  An object that implements the <code>Blob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Blob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Blob createBlob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>NClob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of the <code>NClob</code> interface may\n     * be used to add data to the <code>NClob</code>.\n     * @return An object that implements the <code>NClob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>NClob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    NClob createNClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>SQLXML</code> interface. The object\n     * returned initially contains no data. The <code>createXmlStreamWriter</code> object and\n     * <code>setString</code> method of the <code>SQLXML</code> interface may be used to add data to the <code>SQLXML</code>\n     * object.\n     * @return An object that implements the <code>SQLXML</code> interface\n     * @throws SQLException if an object that implements the <code>SQLXML</code> interface can not\n     * be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     * @since 1.6\n     */\n    SQLXML createSQLXML() throws SQLException;\n\n        /**\n         * Returns true if the connection has not been closed and is still valid.\n         * The driver shall submit a query on the connection or use some other\n         * mechanism that positively verifies the connection is still valid when\n         * this method is called.\n         * <p>\n         * The query submitted by the driver to validate the connection shall be\n         * executed in the context of the current transaction.\n         *\n         * @param timeout -             The time in seconds to wait for the database operation\n         *                                              used to validate the connection to complete.  If\n         *                                              the timeout period expires before the operation\n         *                                              completes, this method returns false.  A value of\n         *                                              0 indicates a timeout is not applied to the\n         *                                              database operation.\n         *\n         * @return true if the connection is valid, false otherwise\n         * @exception SQLException if the value supplied for <code>timeout</code>\n         * is less than 0\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         boolean isValid(int timeout) throws SQLException;\n\n        /**\n         * Sets the value of the client info property specified by name to the\n         * value specified by value.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver\n         * and the maximum length that may be specified for each property.\n         * <p>\n         * The driver stores the value specified in a suitable location in the\n         * database.  For example in a special register, session parameter, or\n         * system table column.  For efficiency the driver may defer setting the\n         * value in the database until the next time a statement is executed or\n         * prepared.  Other than storing the client information in the appropriate\n         * place in the database, these methods shall not alter the behavior of\n         * the connection in anyway.  The values supplied to these methods are\n         * used for accounting, diagnostics and debugging purposes only.\n         * <p>\n         * The driver shall generate a warning if the client info name specified\n         * is not recognized by the driver.\n         * <p>\n         * If the value specified to this method is greater than the maximum\n         * length for the property the driver may either truncate the value and\n         * generate a warning or generate a <code>SQLClientInfoException</code>.  If the driver\n         * generates a <code>SQLClientInfoException</code>, the value specified was not set on the\n         * connection.\n         * <p>\n         * The following are standard client info properties.  Drivers are not\n         * required to support these properties however if the driver supports a\n         * client info property that can be described by one of the standard\n         * properties, the standard property name should be used.\n         *\n         * <ul>\n         * <li>ApplicationName  -       The name of the application currently utilizing\n         *                                                      the connection</li>\n         * <li>ClientUser               -       The name of the user that the application using\n         *                                                      the connection is performing work for.  This may\n         *                                                      not be the same as the user name that was used\n         *                                                      in establishing the connection.</li>\n         * <li>ClientHostname   -       The hostname of the computer the application\n         *                                                      using the connection is running on.</li>\n         * </ul>\n         *\n         * @param name          The name of the client info property to set\n         * @param value         The value to set the client info property to.  If the\n         *                                      value is null, the current value of the specified\n         *                                      property is cleared.\n         *\n         * @throws      SQLClientInfoException if the database server returns an error while\n         *                      setting the client info value on the database server or this method\n         * is called on a closed connection\n         *\n         * @since 1.6\n         */\n         void setClientInfo(String name, String value)\n                throws SQLClientInfoException;\n\n        /**\n     * Sets the value of the connection's client info properties.  The\n     * <code>Properties</code> object contains the names and values of the client info\n     * properties to be set.  The set of client info properties contained in\n     * the properties list replaces the current set of client info properties\n     * on the connection.  If a property that is currently set on the\n     * connection is not present in the properties list, that property is\n     * cleared.  Specifying an empty properties list will clear all of the\n     * properties on the connection.  See <code>setClientInfo (String, String)</code> for\n     * more information.\n     * <p>\n     * If an error occurs in setting any of the client info properties, a\n     * <code>SQLClientInfoException</code> is thrown. The <code>SQLClientInfoException</code>\n     * contains information indicating which client info properties were not set.\n     * The state of the client information is unknown because\n     * some databases do not allow multiple client info properties to be set\n     * atomically.  For those databases, one or more properties may have been\n     * set before the error occurred.\n     *\n     *\n     * @param properties                the list of client info properties to set\n     *\n     * @see java.sql.Connection#setClientInfo(String, String) setClientInfo(String, String)\n     * @since 1.6\n     *\n     * @throws SQLClientInfoException if the database server returns an error while\n     *                  setting the clientInfo values on the database server or this method\n     * is called on a closed connection\n     *\n     */\n         void setClientInfo(Properties properties)\n                throws SQLClientInfoException;\n\n        /**\n         * Returns the value of the client info property specified by name.  This\n         * method may return null if the specified client info property has not\n         * been set and does not have a default value.  This method will also\n         * return null if the specified client info property name is not supported\n         * by the driver.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver.\n         *\n         * @param name          The name of the client info property to retrieve\n         *\n         * @return                      The value of the client info property specified\n         *\n         * @throws SQLException         if the database server returns an error when\n         *                              fetching the client info value from the database\n         *                              or this method is called on a closed connection\n         *\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         String getClientInfo(String name)\n                throws SQLException;\n\n        /**\n         * Returns a list containing the name and current value of each client info\n         * property supported by the driver.  The value of a client info property\n         * may be null if the property has not been set and does not have a\n         * default value.\n         *\n         * @return      A <code>Properties</code> object that contains the name and current value of\n         *                      each of the client info properties supported by the driver.\n         *\n         * @throws      SQLException if the database server returns an error when\n         *                      fetching the client info values from the database\n         * or this method is called on a closed connection\n         *\n         * @since 1.6\n         */\n         Properties getClientInfo()\n                throws SQLException;\n\n/**\n  * Factory method for creating Array objects.\n  *<p>\n  * <b>Note: </b>When <code>createArrayOf</code> is used to create an array object\n  * that maps to a primitive data type, then it is implementation-defined\n  * whether the <code>Array</code> object is an array of that primitive\n  * data type or an array of <code>Object</code>.\n  * <p>\n  * <b>Note: </b>The JDBC driver is responsible for mapping the elements\n  * <code>Object</code> array to the default JDBC SQL type defined in\n  * java.sql.Types for the given class of <code>Object</code>. The default\n  * mapping is specified in Appendix B of the JDBC specification.  If the\n  * resulting JDBC type is not the appropriate type for the given typeName then\n  * it is implementation defined whether an <code>SQLException</code> is\n  * thrown or the driver supports the resulting conversion.\n  *\n  * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n  * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n  *  is the value returned by <code>Array.getBaseTypeName</code>\n  * @param elements the elements that populate the returned object\n  * @return an Array object whose elements map to the specified SQL type\n  * @throws SQLException if a database error occurs, the JDBC type is not\n  *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Array createArrayOf(String typeName, Object[] elements) throws\nSQLException;\n\n/**\n  * Factory method for creating Struct objects.\n  *\n  * @param typeName the SQL type name of the SQL structured type that this <code>Struct</code>\n  * object maps to. The typeName is the name of  a user-defined type that\n  * has been defined for this database. It is the value returned by\n  * <code>Struct.getSQLTypeName</code>.\n\n  * @param attributes the attributes that populate the returned object\n  * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n  * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Struct createStruct(String typeName, Object[] attributes)\nthrows SQLException;\n\n   //--------------------------JDBC 4.1 -----------------------------\n\n   /**\n    * Sets the given schema name to access.\n    * <P>\n    * If the driver does not support schemas, it will\n    * silently ignore this request.\n    * <p>\n    * Calling {@code setSchema} has no effect on previously created or prepared\n    * {@code Statement} objects. It is implementation defined whether a DBMS\n    * prepare operation takes place immediately when the {@code Connection}\n    * method {@code prepareStatement} or {@code prepareCall} is invoked.\n    * For maximum portability, {@code setSchema} should be called before a\n    * {@code Statement} is created or prepared.\n    *\n    * @param schema the name of a schema  in which to work\n    * @exception SQLException if a database access error occurs\n    * or this method is called on a closed connection\n    * @see #getSchema\n    * @since 1.7\n    */\n    void setSchema(String schema) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current schema name.\n     *\n     * @return the current schema name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setSchema\n     * @since 1.7\n     */\n    String getSchema() throws SQLException;\n\n    /**\n     * Terminates an open connection.  Calling <code>abort</code> results in:\n     * <ul>\n     * <li>The connection marked as closed\n     * <li>Closes any physical connection to the database\n     * <li>Releases resources used by the connection\n     * <li>Insures that any thread that is currently accessing the connection\n     * will either progress to completion or throw an <code>SQLException</code>.\n     * </ul>\n     * <p>\n     * Calling <code>abort</code> marks the connection closed and releases any\n     * resources. Calling <code>abort</code> on a closed connection is a\n     * no-op.\n     * <p>\n     * It is possible that the aborting and releasing of the resources that are\n     * held by the connection can take an extended period of time.  When the\n     * <code>abort</code> method returns, the connection will have been marked as\n     * closed and the <code>Executor</code> that was passed as a parameter to abort\n     * may still be executing tasks to release resources.\n     * <p>\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling <code>abort</code>,\n     * this method throws a\n     * <code>java.lang.SecurityException</code>.\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>abort</code>.\n     * @throws java.sql.SQLException if a database access error occurs or\n     * the {@code executor} is {@code null},\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling <code>abort</code>\n     * @see SecurityManager#checkPermission\n     * @see Executor\n     * @since 1.7\n     */\n    void abort(Executor executor) throws SQLException;\n\n    /**\n     *\n     * Sets the maximum period a <code>Connection</code> or\n     * objects created from the <code>Connection</code>\n     * will wait for the database to reply to any one request. If any\n     *  request remains unanswered, the waiting method will\n     * return with a <code>SQLException</code>, and the <code>Connection</code>\n     * or objects created from the <code>Connection</code>  will be marked as\n     * closed. Any subsequent use of\n     * the objects, with the exception of the <code>close</code>,\n     * <code>isClosed</code> or <code>Connection.isValid</code>\n     * methods, will result in  a <code>SQLException</code>.\n     * <p>\n     * <b>Note</b>: This method is intended to address a rare but serious\n     * condition where network partitions can cause threads issuing JDBC calls\n     * to hang uninterruptedly in socket reads, until the OS TCP-TIMEOUT\n     * (typically 10 minutes). This method is related to the\n     * {@link #abort abort() } method which provides an administrator\n     * thread a means to free any such threads in cases where the\n     * JDBC connection is accessible to the administrator thread.\n     * The <code>setNetworkTimeout</code> method will cover cases where\n     * there is no administrator thread, or it has no access to the\n     * connection. This method is severe in it's effects, and should be\n     * given a high enough value so it is never triggered before any more\n     * normal timeouts, such as transaction timeouts.\n     * <p>\n     * JDBC driver implementations  may also choose to support the\n     * {@code setNetworkTimeout} method to impose a limit on database\n     * response time, in environments where no network is present.\n     * <p>\n     * Drivers may internally implement some or all of their API calls with\n     * multiple internal driver-database transmissions, and it is left to the\n     * driver implementation to determine whether the limit will be\n     * applied always to the response to the API call, or to any\n     * single  request made during the API call.\n     * <p>\n     *\n     * This method can be invoked more than once, such as to set a limit for an\n     * area of JDBC code, and to reset to the default on exit from this area.\n     * Invocation of this method has no impact on already outstanding\n     * requests.\n     * <p>\n     * The {@code Statement.setQueryTimeout()} timeout value is independent of the\n     * timeout value specified in {@code setNetworkTimeout}. If the query timeout\n     * expires  before the network timeout then the\n     * statement execution will be canceled. If the network is still\n     * active the result will be that both the statement and connection\n     * are still usable. However if the network timeout expires before\n     * the query timeout or if the statement timeout fails due to network\n     * problems, the connection will be marked as closed, any resources held by\n     * the connection will be released and both the connection and\n     * statement will be unusable.\n     * <p>\n     * When the driver determines that the {@code setNetworkTimeout} timeout\n     * value has expired, the JDBC driver marks the connection\n     * closed and releases any resources held by the connection.\n     * <p>\n     *\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>, this method throws a\n     * <code>java.lang.SecurityException</code>.\n     *\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>setNetworkTimeout</code>.\n     * @param milliseconds The time in milliseconds to wait for the database\n     * operation\n     *  to complete.  If the JDBC driver does not support milliseconds, the\n     * JDBC driver will round the value up to the nearest second.  If the\n     * timeout period expires before the operation\n     * completes, a SQLException will be thrown.\n     * A value of 0 indicates that there is not timeout for database operations.\n     * @throws java.sql.SQLException if a database access error occurs, this\n     * method is called on a closed connection,\n     * the {@code executor} is {@code null},\n     * or the value specified for <code>seconds</code> is less than 0.\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see SecurityManager#checkPermission\n     * @see Statement#setQueryTimeout\n     * @see #getNetworkTimeout\n     * @see #abort\n     * @see Executor\n     * @since 1.7\n     */\n    void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException;\n\n\n    /**\n     * Retrieves the number of milliseconds the driver will\n     * wait for a database request to complete.\n     * If the limit is exceeded, a\n     * <code>SQLException</code> is thrown.\n     *\n     * @return the current timeout limit in milliseconds; zero means there is\n     *         no limit\n     * @throws SQLException if a database access error occurs or\n     * this method is called on a closed <code>Connection</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see #setNetworkTimeout\n     * @since 1.7\n     */\n    int getNetworkTimeout() throws SQLException;\n\n    // JDBC 4.3\n\n     /**\n     * Hints to the driver that a request, an independent unit of work, is beginning\n     * on this connection. Each request is independent of all other requests\n     * with regard to state local to the connection either on the client or the\n     * server. Work done between {@code beginRequest}, {@code endRequest}\n     * pairs does not depend on any other work done on the connection either as\n     * part of another request or outside of any request. A request may include multiple\n     * transactions. There may be dependencies on committed database state as\n     * that is not local to the connection.\n     * <p>\n     * Local state is defined as any state associated with a Connection that is\n     * local to the current Connection either in the client or the database that\n     * is not transparently reproducible.\n     * <p>\n     * Calls to {@code beginRequest} and {@code endRequest}  are not nested.\n     * Multiple calls to {@code beginRequest} without an intervening call\n     * to {@code endRequest} is not an error. The first {@code beginRequest} call\n     * marks the start of the request and subsequent calls are treated as\n     * a no-op\n     * <p>\n     * Use of {@code beginRequest} and {@code endRequest} is optional, vendor\n     * specific and should largely be transparent. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code beginRequest} is called.\n     * Using these methods may improve performance or provide other benefits.\n     * Consult your vendors documentation for additional information.\n     * <p>\n     * It is recommended to\n     * enclose each unit of work in {@code beginRequest}, {@code endRequest}\n     * pairs such that there is no open transaction at the beginning or end of\n     * the request and no dependency on local state that crosses request\n     * boundaries. Committed database state is not local.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     *\n     * @apiNote\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code beginRequest} on the underlying connection\n     * prior to returning a connection to the caller.\n     * <p>\n     * The pooling manager does not need to call {@code beginRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see endRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void beginRequest() throws SQLException {\n       // Default method takes no action\n    }\n\n    /**\n     * Hints to the driver that a request, an independent unit of work,\n     * has completed. Calls to {@code beginRequest}\n     * and {@code endRequest} are not nested. Multiple\n     * calls to {@code endRequest} without an intervening call to {@code beginRequest}\n     * is not an error. The first {@code endRequest} call\n     * marks the request completed and subsequent calls are treated as\n     * a no-op. If {@code endRequest} is called without an initial call to\n     * {@code beginRequest} is a no-op.\n     *<p>\n     * The exact behavior of this method is vendor specific. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code endRequest} is called.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     * @apiNote\n     *\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code endRequest} on the underlying connection\n     * when the applications returns the connection back to the connection pool.\n     * <p>\n     * The pooling manager does not need to call {@code endRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see beginRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void endRequest() throws SQLException {\n            // Default method takes no action\n    }\n\n    /**\n     * Sets and validates the sharding keys for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     *\n     * @apiNote\n     * This method validates that the sharding keys are valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param superShardingKey the super sharding key to be validated against this\n     * connection. The super sharding key may be {@code null}.\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed, otherwise the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding keys are valid\n     * and set on this connection; false if the sharding keys are not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if an error occurs while performing this validation;\n     * a {@code superSharedingKey} is specified\n     * without a {@code shardingKey};\n     * this method is called on a closed {@code connection}; or\n     * the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey,\n            ShardingKey superShardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Sets and validates the sharding key for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method validates  that the sharding key is valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed,else the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding key is valid to be\n     * set on this connection; false if the sharding key is not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if there is an error while performing this validation;\n     * this method is called on a closed {@code connection};\n     * or the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey and superShardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding keys but does not require a\n     * round trip to the database to validate that the sharding keys are valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @param superShardingKey the super sharding key to set on this connection.\n     * The super sharding key may be {@code null}\n     * @throws SQLException if an error  occurs setting the sharding keys;\n     * this method is called on a closed {@code connection}; or\n     * a {@code superSharedingKey} is specified without a {@code shardingKey}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding key but does not require a\n     * round trip to the database to validate that the sharding key is valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @throws SQLException if an error occurs setting the sharding key; or\n     * this method is called on a closed {@code connection}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":110}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":68,"character":40}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":110})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":67,"character":41}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // while ( resultSet.next() ) {[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":111})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":66,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol next[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeQuery[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":98}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":113})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":97}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":94}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todoList) Values ("sleeping")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol sleeping[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":54}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":116})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":64}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeQuery[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol SELECT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":102}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":118})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":95}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":95}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":120})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":94}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Change[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":94}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Change[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":66}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":123})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":65}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol SELECT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol SELECT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":53,"character":82}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO table0 (todo) Values (sleeping)")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":125})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":68}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol sleeping[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":67}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":66}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x).tostring[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":129})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":48}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":130})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":42}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":131})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":40}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x).tostring[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol tostring[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol x[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":133})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":52}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":134})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":135})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":33}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x).tostring[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol arrBuff[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":55}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":31}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":138})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":27}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":139})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":23}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x)[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol query[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":140})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":23}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = arrBuff(x)[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol quer[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ar[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ar[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":48,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val password = "F@ith6193" [0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":142})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":46,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val url = "jdbc:mysql://localhost:3306/project"[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol ith6193[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":143})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":45,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val driver = "com.mysql.cj.jdbc.Driver"[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol cj[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol localhost[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":60}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":145})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":56}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":146})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":48}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol todoList[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":76}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":148})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":73}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":149})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":61}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":150})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":54}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":151})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":55}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol todoList[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INSERT[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol todoList[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     var quer = (arrBuff(x)).tostring[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":153})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol tostring[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol project0[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":155})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":42,"character":46}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // statement.executeUpdate("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":156})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":41,"character":46}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // var query = ("INSERT INTO project0 (todoList) values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol INTO[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":101}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":158})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":99}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":45,"character":45}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val driver = "com.mysql.cj.jdbc.Driver"[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol cj[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":51,"character":51}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection = DriverManager.getConnection(url, username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getConnection[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java","languageId":"java","version":1,"text":"/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.sql;\n\nimport java.util.Properties;\nimport java.util.concurrent.Executor;\n\n/**\n * <P>A connection (session) with a specific\n * database. SQL statements are executed and results are returned\n * within the context of a connection.\n * <P>\n * A <code>Connection</code> object's database is able to provide information\n * describing its tables, its supported SQL grammar, its stored\n * procedures, the capabilities of this connection, and so on. This\n * information is obtained with the <code>getMetaData</code> method.\n *\n * <P><B>Note:</B> When configuring a <code>Connection</code>, JDBC applications\n *  should use the appropriate <code>Connection</code> method such as\n *  <code>setAutoCommit</code> or <code>setTransactionIsolation</code>.\n *  Applications should not invoke SQL commands directly to change the connection's\n *   configuration when there is a JDBC method available.  By default a <code>Connection</code> object is in\n * auto-commit mode, which means that it automatically commits changes\n * after executing each statement. If auto-commit mode has been\n * disabled, the method <code>commit</code> must be called explicitly in\n * order to commit changes; otherwise, database changes will not be saved.\n * <P>\n * A new <code>Connection</code> object created using the JDBC 2.1 core API\n * has an initially empty type map associated with it. A user may enter a\n * custom mapping for a UDT in this type map.\n * When a UDT is retrieved from a data source with the\n * method <code>ResultSet.getObject</code>, the <code>getObject</code> method\n * will check the connection's type map to see if there is an entry for that\n * UDT.  If so, the <code>getObject</code> method will map the UDT to the\n * class indicated.  If there is no entry, the UDT will be mapped using the\n * standard mapping.\n * <p>\n * A user may create a new type map, which is a <code>java.util.Map</code>\n * object, make an entry in it, and pass it to the <code>java.sql</code>\n * methods that can perform custom mapping.  In this case, the method\n * will use the given type map instead of the one associated with\n * the connection.\n * <p>\n * For example, the following code fragment specifies that the SQL\n * type <code>ATHLETES</code> will be mapped to the class\n * <code>Athletes</code> in the Java programming language.\n * The code fragment retrieves the type map for the <code>Connection\n * </code> object <code>con</code>, inserts the entry into it, and then sets\n * the type map with the new entry as the connection's type map.\n * <pre>\n *      java.util.Map map = con.getTypeMap();\n *      map.put(\"mySchemaName.ATHLETES\", Class.forName(\"Athletes\"));\n *      con.setTypeMap(map);\n * </pre>\n *\n * @see DriverManager#getConnection\n * @see Statement\n * @see ResultSet\n * @see DatabaseMetaData\n * @since 1.1\n */\npublic interface Connection  extends Wrapper, AutoCloseable {\n\n    /**\n     * Creates a <code>Statement</code> object for sending\n     * SQL statements to the database.\n     * SQL statements without parameters are normally\n     * executed using <code>Statement</code> objects. If the same SQL statement\n     * is executed many times, it may be more efficient to use a\n     * <code>PreparedStatement</code> object.\n     * <P>\n     * Result sets created using the returned <code>Statement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @return a new default <code>Statement</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    Statement createStatement() throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object for sending\n     * parameterized SQL statements to the database.\n     * <P>\n     * A SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     *\n     * <P><B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain <code>SQLException</code> objects.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     * parameter placeholders\n     * @return a new default <code>PreparedStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    PreparedStatement prepareStatement(String sql)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object for calling\n     * database stored procedures.\n     * The <code>CallableStatement</code> object provides\n     * methods for setting up its IN and OUT parameters, and\n     * methods for executing the call to a stored procedure.\n     *\n     * <P><B>Note:</B> This method is optimized for handling stored\n     * procedure call statements. Some drivers may send the call\n     * statement to the database when the method <code>prepareCall</code>\n     * is done; others\n     * may wait until the <code>CallableStatement</code> object\n     * is executed. This has no\n     * direct effect on users; however, it does affect which method\n     * throws certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>CallableStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders. Typically this statement is specified using JDBC\n     * call escape syntax.\n     * @return a new default <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    CallableStatement prepareCall(String sql) throws SQLException;\n\n    /**\n     * Converts the given SQL statement into the system's native SQL grammar.\n     * A driver may convert the JDBC SQL grammar into its system's\n     * native SQL grammar prior to sending it. This method returns the\n     * native form of the statement that the driver would have sent.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders\n     * @return the native form of this statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    String nativeSQL(String sql) throws SQLException;\n\n    /**\n     * Sets this connection's auto-commit mode to the given state.\n     * If a connection is in auto-commit mode, then all its SQL\n     * statements will be executed and committed as individual\n     * transactions.  Otherwise, its SQL statements are grouped into\n     * transactions that are terminated by a call to either\n     * the method <code>commit</code> or the method <code>rollback</code>.\n     * By default, new connections are in auto-commit\n     * mode.\n     * <P>\n     * The commit occurs when the statement completes. The time when the statement\n     * completes depends on the type of SQL Statement:\n     * <ul>\n     * <li>For DML statements, such as Insert, Update or Delete, and DDL statements,\n     * the statement is complete as soon as it has finished executing.\n     * <li>For Select statements, the statement is complete when the associated result\n     * set is closed.\n     * <li>For <code>CallableStatement</code> objects or for statements that return\n     * multiple results, the statement is complete\n     * when all of the associated result sets have been closed, and all update\n     * counts and output parameters have been retrieved.\n     *</ul>\n     * <P>\n     * <B>NOTE:</B>  If this method is called during a transaction and the\n     * auto-commit mode is changed, the transaction is committed.  If\n     * <code>setAutoCommit</code> is called and the auto-commit mode is\n     * not changed, the call is a no-op.\n     *\n     * @param autoCommit <code>true</code> to enable auto-commit mode;\n     *         <code>false</code> to disable it\n     * @exception SQLException if a database access error occurs,\n     *  setAutoCommit(true) is called while participating in a distributed transaction,\n     * or this method is called on a closed connection\n     * @see #getAutoCommit\n     */\n    void setAutoCommit(boolean autoCommit) throws SQLException;\n\n    /**\n     * Retrieves the current auto-commit mode for this <code>Connection</code>\n     * object.\n     *\n     * @return the current state of this <code>Connection</code> object's\n     *         auto-commit mode\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setAutoCommit\n     */\n    boolean getAutoCommit() throws SQLException;\n\n    /**\n     * Makes all changes made since the previous\n     * commit/rollback permanent and releases any database locks\n     * currently held by this <code>Connection</code> object.\n     * This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * if this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void commit() throws SQLException;\n\n    /**\n     * Undoes all changes made in the current transaction\n     * and releases any database locks currently held\n     * by this <code>Connection</code> object. This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void rollback() throws SQLException;\n\n    /**\n     * Releases this <code>Connection</code> object's database and JDBC resources\n     * immediately instead of waiting for them to be automatically released.\n     * <P>\n     * Calling the method <code>close</code> on a <code>Connection</code>\n     * object that is already closed is a no-op.\n     * <P>\n     * It is <b>strongly recommended</b> that an application explicitly\n     * commits or rolls back an active transaction prior to calling the\n     * <code>close</code> method.  If the <code>close</code> method is called\n     * and there is an active transaction, the results are implementation-defined.\n     *\n     * @exception SQLException if a database access error occurs\n     */\n    void close() throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code> object has been\n     * closed.  A connection is closed if the method <code>close</code>\n     * has been called on it or if certain fatal errors have occurred.\n     * This method is guaranteed to return <code>true</code> only when\n     * it is called after the method <code>Connection.close</code> has\n     * been called.\n     * <P>\n     * This method generally cannot be called to determine whether a\n     * connection to a database is valid or invalid.  A typical client\n     * can determine that a connection is invalid by catching any\n     * exceptions that might be thrown when an operation is attempted.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is closed; <code>false</code> if it is still open\n     * @exception SQLException if a database access error occurs\n     */\n    boolean isClosed() throws SQLException;\n\n    //======================================================================\n    // Advanced features:\n\n    /**\n     * Retrieves a <code>DatabaseMetaData</code> object that contains\n     * metadata about the database to which this\n     * <code>Connection</code> object represents a connection.\n     * The metadata includes information about the database's\n     * tables, its supported SQL grammar, its stored\n     * procedures, the capabilities of this connection, and so on.\n     *\n     * @return a <code>DatabaseMetaData</code> object for this\n     *         <code>Connection</code> object\n     * @exception  SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    DatabaseMetaData getMetaData() throws SQLException;\n\n    /**\n     * Puts this connection in read-only mode as a hint to the driver to enable\n     * database optimizations.\n     *\n     * <P><B>Note:</B> This method cannot be called during a transaction.\n     *\n     * @param readOnly <code>true</code> enables read-only mode;\n     *        <code>false</code> disables it\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or this\n     *            method is called during a transaction\n     */\n    void setReadOnly(boolean readOnly) throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code>\n     * object is in read-only mode.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is read-only; <code>false</code> otherwise\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    boolean isReadOnly() throws SQLException;\n\n    /**\n     * Sets the given catalog name in order to select\n     * a subspace of this <code>Connection</code> object's database\n     * in which to work.\n     * <P>\n     * If the driver does not support catalogs, it will\n     * silently ignore this request.\n     * <p>\n     * Calling {@code setCatalog} has no effect on previously created or prepared\n     * {@code Statement} objects. It is implementation defined whether a DBMS\n     * prepare operation takes place immediately when the {@code Connection}\n     * method {@code prepareStatement} or {@code prepareCall} is invoked.\n     * For maximum portability, {@code setCatalog} should be called before a\n     * {@code Statement} is created or prepared.\n     *\n     * @param catalog the name of a catalog (subspace in this\n     *        <code>Connection</code> object's database) in which to work\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #getCatalog\n     */\n    void setCatalog(String catalog) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current catalog name.\n     *\n     * @return the current catalog name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setCatalog\n     */\n    String getCatalog() throws SQLException;\n\n    /**\n     * A constant indicating that transactions are not supported.\n     */\n    int TRANSACTION_NONE             = 0;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads can occur.\n     * This level allows a row changed by one transaction to be read\n     * by another transaction before any changes in that row have been\n     * committed (a \"dirty read\").  If any of the changes are rolled back,\n     * the second transaction will have retrieved an invalid row.\n     */\n    int TRANSACTION_READ_UNCOMMITTED = 1;\n\n    /**\n     * A constant indicating that\n     * dirty reads are prevented; non-repeatable reads and phantom\n     * reads can occur.  This level only prohibits a transaction\n     * from reading a row with uncommitted changes in it.\n     */\n    int TRANSACTION_READ_COMMITTED   = 2;\n\n    /**\n     * A constant indicating that\n     * dirty reads and non-repeatable reads are prevented; phantom\n     * reads can occur.  This level prohibits a transaction from\n     * reading a row with uncommitted changes in it, and it also\n     * prohibits the situation where one transaction reads a row,\n     * a second transaction alters the row, and the first transaction\n     * rereads the row, getting different values the second time\n     * (a \"non-repeatable read\").\n     */\n    int TRANSACTION_REPEATABLE_READ  = 4;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads are prevented.\n     * This level includes the prohibitions in\n     * <code>TRANSACTION_REPEATABLE_READ</code> and further prohibits the\n     * situation where one transaction reads all rows that satisfy\n     * a <code>WHERE</code> condition, a second transaction inserts a row that\n     * satisfies that <code>WHERE</code> condition, and the first transaction\n     * rereads for the same condition, retrieving the additional\n     * \"phantom\" row in the second read.\n     */\n    int TRANSACTION_SERIALIZABLE     = 8;\n\n    /**\n     * Attempts to change the transaction isolation level for this\n     * <code>Connection</code> object to the one given.\n     * The constants defined in the interface <code>Connection</code>\n     * are the possible transaction isolation levels.\n     * <P>\n     * <B>Note:</B> If this method is called during a transaction, the result\n     * is implementation-defined.\n     *\n     * @param level one of the following <code>Connection</code> constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>, or\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>.\n     *        (Note that <code>Connection.TRANSACTION_NONE</code> cannot be used\n     *        because it specifies that transactions are not supported.)\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameter is not one of the <code>Connection</code>\n     *            constants\n     * @see DatabaseMetaData#supportsTransactionIsolationLevel\n     * @see #getTransactionIsolation\n     */\n    void setTransactionIsolation(int level) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current\n     * transaction isolation level.\n     *\n     * @return the current transaction isolation level, which will be one\n     *         of the following constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>,\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>, or\n     *        <code>Connection.TRANSACTION_NONE</code>.\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setTransactionIsolation\n     */\n    int getTransactionIsolation() throws SQLException;\n\n    /**\n     * Retrieves the first warning reported by calls on this\n     * <code>Connection</code> object.  If there is more than one\n     * warning, subsequent warnings will be chained to the first one\n     * and can be retrieved by calling the method\n     * <code>SQLWarning.getNextWarning</code> on the warning\n     * that was retrieved previously.\n     * <P>\n     * This method may not be\n     * called on a closed connection; doing so will cause an\n     * <code>SQLException</code> to be thrown.\n     *\n     * <P><B>Note:</B> Subsequent warnings will be chained to this\n     * SQLWarning.\n     *\n     * @return the first <code>SQLWarning</code> object or <code>null</code>\n     *         if there are none\n     * @exception SQLException if a database access error occurs or\n     *            this method is called on a closed connection\n     * @see SQLWarning\n     */\n    SQLWarning getWarnings() throws SQLException;\n\n    /**\n     * Clears all warnings reported for this <code>Connection</code> object.\n     * After a call to this method, the method <code>getWarnings</code>\n     * returns <code>null</code> until a new warning is\n     * reported for this <code>Connection</code> object.\n     *\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    void clearWarnings() throws SQLException;\n\n\n    //--------------------------JDBC 2.0-----------------------------\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param resultSetType a result set type; one of\n     *        <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *        <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *        <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type and\n     *         concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     *\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new PreparedStatement object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this method\n     * is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency) throws SQLException;\n\n    /**\n     * Retrieves the <code>Map</code> object associated with this\n     * <code>Connection</code> object.\n     * Unless the application has added an entry, the type map returned\n     * will be empty.\n     * <p>\n     * You must invoke <code>setTypeMap</code> after making changes to the\n     * <code>Map</code> object returned from\n     *  <code>getTypeMap</code> as a JDBC driver may create an internal\n     * copy of the <code>Map</code> object passed to <code>setTypeMap</code>:\n     *\n     * <pre>\n     *      Map&lt;String,Class&lt;?&gt;&gt; myMap = con.getTypeMap();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @return the <code>java.util.Map</code> object associated\n     *         with this <code>Connection</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #setTypeMap\n     */\n    java.util.Map<String,Class<?>> getTypeMap() throws SQLException;\n\n    /**\n     * Installs the given <code>TypeMap</code> object as the type map for\n     * this <code>Connection</code> object.  The type map will be used for the\n     * custom mapping of SQL structured types and distinct types.\n     * <p>\n     * You must set the values for the <code>TypeMap</code> prior to\n     * callng <code>setMap</code> as a JDBC driver may create an internal copy\n     * of the <code>TypeMap</code>:\n     *\n     * <pre>\n     *      Map myMap&lt;String,Class&lt;?&gt;&gt; = new HashMap&lt;String,Class&lt;?&gt;&gt;();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @param map the <code>java.util.Map</code> object to install\n     *        as the replacement for this <code>Connection</code>\n     *        object's default type map\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection or\n     *        the given parameter is not a <code>java.util.Map</code>\n     *        object\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #getTypeMap\n     */\n    void setTypeMap(java.util.Map<String,Class<?>> map) throws SQLException;\n\n    //--------------------------JDBC 3.0-----------------------------\n\n\n    /**\n     * Changes the default holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object to the given\n     * holdability.  The default holdability of <code>ResultSet</code> objects\n     * can be determined by invoking\n     * {@link DatabaseMetaData#getResultSetHoldability}.\n     *\n     * @param holdability a <code>ResultSet</code> holdability constant; one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access occurs, this method is called\n     * on a closed connection, or the given parameter\n     *         is not a <code>ResultSet</code> constant indicating holdability\n     * @exception SQLFeatureNotSupportedException if the given holdability is not supported\n     * @see #getHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    void setHoldability(int holdability) throws SQLException;\n\n    /**\n     * Retrieves the current holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object.\n     *\n     * @return the holdability, one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    int getHoldability() throws SQLException;\n\n    /**\n     * Creates an unnamed savepoint in the current transaction and\n     * returns the new <code>Savepoint</code> object that represents it.\n     *\n     *<p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint() throws SQLException;\n\n    /**\n     * Creates a savepoint with the given name in the current transaction\n     * and returns the new <code>Savepoint</code> object that represents it.\n     *\n     * <p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @param name a <code>String</code> containing the name of the savepoint\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n          * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint(String name) throws SQLException;\n\n    /**\n     * Undoes all changes made after the given <code>Savepoint</code> object\n     * was set.\n     * <P>\n     * This method should be used only when auto-commit has been disabled.\n     *\n     * @param savepoint the <code>Savepoint</code> object to roll back to\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection,\n     *            the <code>Savepoint</code> object is no longer valid,\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @see #rollback\n     * @since 1.4\n     */\n    void rollback(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Removes the specified <code>Savepoint</code>  and subsequent <code>Savepoint</code> objects from the current\n     * transaction. Any reference to the savepoint after it have been removed\n     * will cause an <code>SQLException</code> to be thrown.\n     *\n     * @param savepoint the <code>Savepoint</code> object to be removed\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or\n     *            the given <code>Savepoint</code> object is not a valid\n     *            savepoint in the current transaction\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.4\n     */\n    void releaseSavepoint(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency,\n                              int resultSetHoldability) throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * <P>\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency, int resultSetHoldability)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type, result set concurrency type and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>CallableStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency,\n                                  int resultSetHoldability) throws SQLException;\n\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object that has\n     * the capability to retrieve auto-generated keys. The given constant\n     * tells the driver whether it should make auto-generated keys\n     * available for retrieval.  This parameter is ignored if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param autoGeneratedKeys a flag indicating whether auto-generated keys\n     *        should be returned; one of\n     *        <code>Statement.RETURN_GENERATED_KEYS</code> or\n     *        <code>Statement.NO_GENERATED_KEYS</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will have the capability of\n     *         returning auto-generated keys\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection\n     *         or the given parameter is not a <code>Statement</code>\n     *         constant indicating whether auto-generated keys should be\n     *         returned\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the indexes of the columns in the target\n     * table that contain the auto-generated keys that should be made\n     * available.  The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnIndexes an array of column indexes indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         indexes\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int columnIndexes[])\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the names of the columns in the target\n     * table that contain the auto-generated keys that should be returned.\n     * The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnNames an array of column names indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         names\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, String columnNames[])\n        throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Clob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of\n     * the <code>Clob</code> interface may be used to add data to the <code>Clob</code>.\n     * @return An object that implements the <code>Clob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Clob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Clob createClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Blob</code> interface. The object\n     * returned initially contains no data.  The <code>setBinaryStream</code> and\n     * <code>setBytes</code> methods of the <code>Blob</code> interface may be used to add data to\n     * the <code>Blob</code>.\n     * @return  An object that implements the <code>Blob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Blob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Blob createBlob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>NClob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of the <code>NClob</code> interface may\n     * be used to add data to the <code>NClob</code>.\n     * @return An object that implements the <code>NClob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>NClob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    NClob createNClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>SQLXML</code> interface. The object\n     * returned initially contains no data. The <code>createXmlStreamWriter</code> object and\n     * <code>setString</code> method of the <code>SQLXML</code> interface may be used to add data to the <code>SQLXML</code>\n     * object.\n     * @return An object that implements the <code>SQLXML</code> interface\n     * @throws SQLException if an object that implements the <code>SQLXML</code> interface can not\n     * be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     * @since 1.6\n     */\n    SQLXML createSQLXML() throws SQLException;\n\n        /**\n         * Returns true if the connection has not been closed and is still valid.\n         * The driver shall submit a query on the connection or use some other\n         * mechanism that positively verifies the connection is still valid when\n         * this method is called.\n         * <p>\n         * The query submitted by the driver to validate the connection shall be\n         * executed in the context of the current transaction.\n         *\n         * @param timeout -             The time in seconds to wait for the database operation\n         *                                              used to validate the connection to complete.  If\n         *                                              the timeout period expires before the operation\n         *                                              completes, this method returns false.  A value of\n         *                                              0 indicates a timeout is not applied to the\n         *                                              database operation.\n         *\n         * @return true if the connection is valid, false otherwise\n         * @exception SQLException if the value supplied for <code>timeout</code>\n         * is less than 0\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         boolean isValid(int timeout) throws SQLException;\n\n        /**\n         * Sets the value of the client info property specified by name to the\n         * value specified by value.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver\n         * and the maximum length that may be specified for each property.\n         * <p>\n         * The driver stores the value specified in a suitable location in the\n         * database.  For example in a special register, session parameter, or\n         * system table column.  For efficiency the driver may defer setting the\n         * value in the database until the next time a statement is executed or\n         * prepared.  Other than storing the client information in the appropriate\n         * place in the database, these methods shall not alter the behavior of\n         * the connection in anyway.  The values supplied to these methods are\n         * used for accounting, diagnostics and debugging purposes only.\n         * <p>\n         * The driver shall generate a warning if the client info name specified\n         * is not recognized by the driver.\n         * <p>\n         * If the value specified to this method is greater than the maximum\n         * length for the property the driver may either truncate the value and\n         * generate a warning or generate a <code>SQLClientInfoException</code>.  If the driver\n         * generates a <code>SQLClientInfoException</code>, the value specified was not set on the\n         * connection.\n         * <p>\n         * The following are standard client info properties.  Drivers are not\n         * required to support these properties however if the driver supports a\n         * client info property that can be described by one of the standard\n         * properties, the standard property name should be used.\n         *\n         * <ul>\n         * <li>ApplicationName  -       The name of the application currently utilizing\n         *                                                      the connection</li>\n         * <li>ClientUser               -       The name of the user that the application using\n         *                                                      the connection is performing work for.  This may\n         *                                                      not be the same as the user name that was used\n         *                                                      in establishing the connection.</li>\n         * <li>ClientHostname   -       The hostname of the computer the application\n         *                                                      using the connection is running on.</li>\n         * </ul>\n         *\n         * @param name          The name of the client info property to set\n         * @param value         The value to set the client info property to.  If the\n         *                                      value is null, the current value of the specified\n         *                                      property is cleared.\n         *\n         * @throws      SQLClientInfoException if the database server returns an error while\n         *                      setting the client info value on the database server or this method\n         * is called on a closed connection\n         *\n         * @since 1.6\n         */\n         void setClientInfo(String name, String value)\n                throws SQLClientInfoException;\n\n        /**\n     * Sets the value of the connection's client info properties.  The\n     * <code>Properties</code> object contains the names and values of the client info\n     * properties to be set.  The set of client info properties contained in\n     * the properties list replaces the current set of client info properties\n     * on the connection.  If a property that is currently set on the\n     * connection is not present in the properties list, that property is\n     * cleared.  Specifying an empty properties list will clear all of the\n     * properties on the connection.  See <code>setClientInfo (String, String)</code> for\n     * more information.\n     * <p>\n     * If an error occurs in setting any of the client info properties, a\n     * <code>SQLClientInfoException</code> is thrown. The <code>SQLClientInfoException</code>\n     * contains information indicating which client info properties were not set.\n     * The state of the client information is unknown because\n     * some databases do not allow multiple client info properties to be set\n     * atomically.  For those databases, one or more properties may have been\n     * set before the error occurred.\n     *\n     *\n     * @param properties                the list of client info properties to set\n     *\n     * @see java.sql.Connection#setClientInfo(String, String) setClientInfo(String, String)\n     * @since 1.6\n     *\n     * @throws SQLClientInfoException if the database server returns an error while\n     *                  setting the clientInfo values on the database server or this method\n     * is called on a closed connection\n     *\n     */\n         void setClientInfo(Properties properties)\n                throws SQLClientInfoException;\n\n        /**\n         * Returns the value of the client info property specified by name.  This\n         * method may return null if the specified client info property has not\n         * been set and does not have a default value.  This method will also\n         * return null if the specified client info property name is not supported\n         * by the driver.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver.\n         *\n         * @param name          The name of the client info property to retrieve\n         *\n         * @return                      The value of the client info property specified\n         *\n         * @throws SQLException         if the database server returns an error when\n         *                              fetching the client info value from the database\n         *                              or this method is called on a closed connection\n         *\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         String getClientInfo(String name)\n                throws SQLException;\n\n        /**\n         * Returns a list containing the name and current value of each client info\n         * property supported by the driver.  The value of a client info property\n         * may be null if the property has not been set and does not have a\n         * default value.\n         *\n         * @return      A <code>Properties</code> object that contains the name and current value of\n         *                      each of the client info properties supported by the driver.\n         *\n         * @throws      SQLException if the database server returns an error when\n         *                      fetching the client info values from the database\n         * or this method is called on a closed connection\n         *\n         * @since 1.6\n         */\n         Properties getClientInfo()\n                throws SQLException;\n\n/**\n  * Factory method for creating Array objects.\n  *<p>\n  * <b>Note: </b>When <code>createArrayOf</code> is used to create an array object\n  * that maps to a primitive data type, then it is implementation-defined\n  * whether the <code>Array</code> object is an array of that primitive\n  * data type or an array of <code>Object</code>.\n  * <p>\n  * <b>Note: </b>The JDBC driver is responsible for mapping the elements\n  * <code>Object</code> array to the default JDBC SQL type defined in\n  * java.sql.Types for the given class of <code>Object</code>. The default\n  * mapping is specified in Appendix B of the JDBC specification.  If the\n  * resulting JDBC type is not the appropriate type for the given typeName then\n  * it is implementation defined whether an <code>SQLException</code> is\n  * thrown or the driver supports the resulting conversion.\n  *\n  * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n  * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n  *  is the value returned by <code>Array.getBaseTypeName</code>\n  * @param elements the elements that populate the returned object\n  * @return an Array object whose elements map to the specified SQL type\n  * @throws SQLException if a database error occurs, the JDBC type is not\n  *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Array createArrayOf(String typeName, Object[] elements) throws\nSQLException;\n\n/**\n  * Factory method for creating Struct objects.\n  *\n  * @param typeName the SQL type name of the SQL structured type that this <code>Struct</code>\n  * object maps to. The typeName is the name of  a user-defined type that\n  * has been defined for this database. It is the value returned by\n  * <code>Struct.getSQLTypeName</code>.\n\n  * @param attributes the attributes that populate the returned object\n  * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n  * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Struct createStruct(String typeName, Object[] attributes)\nthrows SQLException;\n\n   //--------------------------JDBC 4.1 -----------------------------\n\n   /**\n    * Sets the given schema name to access.\n    * <P>\n    * If the driver does not support schemas, it will\n    * silently ignore this request.\n    * <p>\n    * Calling {@code setSchema} has no effect on previously created or prepared\n    * {@code Statement} objects. It is implementation defined whether a DBMS\n    * prepare operation takes place immediately when the {@code Connection}\n    * method {@code prepareStatement} or {@code prepareCall} is invoked.\n    * For maximum portability, {@code setSchema} should be called before a\n    * {@code Statement} is created or prepared.\n    *\n    * @param schema the name of a schema  in which to work\n    * @exception SQLException if a database access error occurs\n    * or this method is called on a closed connection\n    * @see #getSchema\n    * @since 1.7\n    */\n    void setSchema(String schema) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current schema name.\n     *\n     * @return the current schema name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setSchema\n     * @since 1.7\n     */\n    String getSchema() throws SQLException;\n\n    /**\n     * Terminates an open connection.  Calling <code>abort</code> results in:\n     * <ul>\n     * <li>The connection marked as closed\n     * <li>Closes any physical connection to the database\n     * <li>Releases resources used by the connection\n     * <li>Insures that any thread that is currently accessing the connection\n     * will either progress to completion or throw an <code>SQLException</code>.\n     * </ul>\n     * <p>\n     * Calling <code>abort</code> marks the connection closed and releases any\n     * resources. Calling <code>abort</code> on a closed connection is a\n     * no-op.\n     * <p>\n     * It is possible that the aborting and releasing of the resources that are\n     * held by the connection can take an extended period of time.  When the\n     * <code>abort</code> method returns, the connection will have been marked as\n     * closed and the <code>Executor</code> that was passed as a parameter to abort\n     * may still be executing tasks to release resources.\n     * <p>\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling <code>abort</code>,\n     * this method throws a\n     * <code>java.lang.SecurityException</code>.\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>abort</code>.\n     * @throws java.sql.SQLException if a database access error occurs or\n     * the {@code executor} is {@code null},\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling <code>abort</code>\n     * @see SecurityManager#checkPermission\n     * @see Executor\n     * @since 1.7\n     */\n    void abort(Executor executor) throws SQLException;\n\n    /**\n     *\n     * Sets the maximum period a <code>Connection</code> or\n     * objects created from the <code>Connection</code>\n     * will wait for the database to reply to any one request. If any\n     *  request remains unanswered, the waiting method will\n     * return with a <code>SQLException</code>, and the <code>Connection</code>\n     * or objects created from the <code>Connection</code>  will be marked as\n     * closed. Any subsequent use of\n     * the objects, with the exception of the <code>close</code>,\n     * <code>isClosed</code> or <code>Connection.isValid</code>\n     * methods, will result in  a <code>SQLException</code>.\n     * <p>\n     * <b>Note</b>: This method is intended to address a rare but serious\n     * condition where network partitions can cause threads issuing JDBC calls\n     * to hang uninterruptedly in socket reads, until the OS TCP-TIMEOUT\n     * (typically 10 minutes). This method is related to the\n     * {@link #abort abort() } method which provides an administrator\n     * thread a means to free any such threads in cases where the\n     * JDBC connection is accessible to the administrator thread.\n     * The <code>setNetworkTimeout</code> method will cover cases where\n     * there is no administrator thread, or it has no access to the\n     * connection. This method is severe in it's effects, and should be\n     * given a high enough value so it is never triggered before any more\n     * normal timeouts, such as transaction timeouts.\n     * <p>\n     * JDBC driver implementations  may also choose to support the\n     * {@code setNetworkTimeout} method to impose a limit on database\n     * response time, in environments where no network is present.\n     * <p>\n     * Drivers may internally implement some or all of their API calls with\n     * multiple internal driver-database transmissions, and it is left to the\n     * driver implementation to determine whether the limit will be\n     * applied always to the response to the API call, or to any\n     * single  request made during the API call.\n     * <p>\n     *\n     * This method can be invoked more than once, such as to set a limit for an\n     * area of JDBC code, and to reset to the default on exit from this area.\n     * Invocation of this method has no impact on already outstanding\n     * requests.\n     * <p>\n     * The {@code Statement.setQueryTimeout()} timeout value is independent of the\n     * timeout value specified in {@code setNetworkTimeout}. If the query timeout\n     * expires  before the network timeout then the\n     * statement execution will be canceled. If the network is still\n     * active the result will be that both the statement and connection\n     * are still usable. However if the network timeout expires before\n     * the query timeout or if the statement timeout fails due to network\n     * problems, the connection will be marked as closed, any resources held by\n     * the connection will be released and both the connection and\n     * statement will be unusable.\n     * <p>\n     * When the driver determines that the {@code setNetworkTimeout} timeout\n     * value has expired, the JDBC driver marks the connection\n     * closed and releases any resources held by the connection.\n     * <p>\n     *\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>, this method throws a\n     * <code>java.lang.SecurityException</code>.\n     *\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>setNetworkTimeout</code>.\n     * @param milliseconds The time in milliseconds to wait for the database\n     * operation\n     *  to complete.  If the JDBC driver does not support milliseconds, the\n     * JDBC driver will round the value up to the nearest second.  If the\n     * timeout period expires before the operation\n     * completes, a SQLException will be thrown.\n     * A value of 0 indicates that there is not timeout for database operations.\n     * @throws java.sql.SQLException if a database access error occurs, this\n     * method is called on a closed connection,\n     * the {@code executor} is {@code null},\n     * or the value specified for <code>seconds</code> is less than 0.\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see SecurityManager#checkPermission\n     * @see Statement#setQueryTimeout\n     * @see #getNetworkTimeout\n     * @see #abort\n     * @see Executor\n     * @since 1.7\n     */\n    void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException;\n\n\n    /**\n     * Retrieves the number of milliseconds the driver will\n     * wait for a database request to complete.\n     * If the limit is exceeded, a\n     * <code>SQLException</code> is thrown.\n     *\n     * @return the current timeout limit in milliseconds; zero means there is\n     *         no limit\n     * @throws SQLException if a database access error occurs or\n     * this method is called on a closed <code>Connection</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see #setNetworkTimeout\n     * @since 1.7\n     */\n    int getNetworkTimeout() throws SQLException;\n\n    // JDBC 4.3\n\n     /**\n     * Hints to the driver that a request, an independent unit of work, is beginning\n     * on this connection. Each request is independent of all other requests\n     * with regard to state local to the connection either on the client or the\n     * server. Work done between {@code beginRequest}, {@code endRequest}\n     * pairs does not depend on any other work done on the connection either as\n     * part of another request or outside of any request. A request may include multiple\n     * transactions. There may be dependencies on committed database state as\n     * that is not local to the connection.\n     * <p>\n     * Local state is defined as any state associated with a Connection that is\n     * local to the current Connection either in the client or the database that\n     * is not transparently reproducible.\n     * <p>\n     * Calls to {@code beginRequest} and {@code endRequest}  are not nested.\n     * Multiple calls to {@code beginRequest} without an intervening call\n     * to {@code endRequest} is not an error. The first {@code beginRequest} call\n     * marks the start of the request and subsequent calls are treated as\n     * a no-op\n     * <p>\n     * Use of {@code beginRequest} and {@code endRequest} is optional, vendor\n     * specific and should largely be transparent. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code beginRequest} is called.\n     * Using these methods may improve performance or provide other benefits.\n     * Consult your vendors documentation for additional information.\n     * <p>\n     * It is recommended to\n     * enclose each unit of work in {@code beginRequest}, {@code endRequest}\n     * pairs such that there is no open transaction at the beginning or end of\n     * the request and no dependency on local state that crosses request\n     * boundaries. Committed database state is not local.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     *\n     * @apiNote\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code beginRequest} on the underlying connection\n     * prior to returning a connection to the caller.\n     * <p>\n     * The pooling manager does not need to call {@code beginRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see endRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void beginRequest() throws SQLException {\n       // Default method takes no action\n    }\n\n    /**\n     * Hints to the driver that a request, an independent unit of work,\n     * has completed. Calls to {@code beginRequest}\n     * and {@code endRequest} are not nested. Multiple\n     * calls to {@code endRequest} without an intervening call to {@code beginRequest}\n     * is not an error. The first {@code endRequest} call\n     * marks the request completed and subsequent calls are treated as\n     * a no-op. If {@code endRequest} is called without an initial call to\n     * {@code beginRequest} is a no-op.\n     *<p>\n     * The exact behavior of this method is vendor specific. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code endRequest} is called.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     * @apiNote\n     *\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code endRequest} on the underlying connection\n     * when the applications returns the connection back to the connection pool.\n     * <p>\n     * The pooling manager does not need to call {@code endRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see beginRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void endRequest() throws SQLException {\n            // Default method takes no action\n    }\n\n    /**\n     * Sets and validates the sharding keys for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     *\n     * @apiNote\n     * This method validates that the sharding keys are valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param superShardingKey the super sharding key to be validated against this\n     * connection. The super sharding key may be {@code null}.\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed, otherwise the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding keys are valid\n     * and set on this connection; false if the sharding keys are not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if an error occurs while performing this validation;\n     * a {@code superSharedingKey} is specified\n     * without a {@code shardingKey};\n     * this method is called on a closed {@code connection}; or\n     * the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey,\n            ShardingKey superShardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Sets and validates the sharding key for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method validates  that the sharding key is valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed,else the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding key is valid to be\n     * set on this connection; false if the sharding key is not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if there is an error while performing this validation;\n     * this method is called on a closed {@code connection};\n     * or the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey and superShardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding keys but does not require a\n     * round trip to the database to validate that the sharding keys are valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @param superShardingKey the super sharding key to set on this connection.\n     * The super sharding key may be {@code null}\n     * @throws SQLException if an error  occurs setting the sharding keys;\n     * this method is called on a closed {@code connection}; or\n     * a {@code superSharedingKey} is specified without a {@code shardingKey}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding key but does not require a\n     * round trip to the database to validate that the sharding key is valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @throws SQLException if an error occurs setting the sharding key; or\n     * this method is called on a closed {@code connection}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":85}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol quer[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":54,"character":85}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol quer[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":57,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":27}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":165})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":29}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":166})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":56,"character":32}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol connection[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol connection[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol close[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java","languageId":"java","version":1,"text":"/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.sql;\n\nimport java.util.Properties;\nimport java.util.concurrent.Executor;\n\n/**\n * <P>A connection (session) with a specific\n * database. SQL statements are executed and results are returned\n * within the context of a connection.\n * <P>\n * A <code>Connection</code> object's database is able to provide information\n * describing its tables, its supported SQL grammar, its stored\n * procedures, the capabilities of this connection, and so on. This\n * information is obtained with the <code>getMetaData</code> method.\n *\n * <P><B>Note:</B> When configuring a <code>Connection</code>, JDBC applications\n *  should use the appropriate <code>Connection</code> method such as\n *  <code>setAutoCommit</code> or <code>setTransactionIsolation</code>.\n *  Applications should not invoke SQL commands directly to change the connection's\n *   configuration when there is a JDBC method available.  By default a <code>Connection</code> object is in\n * auto-commit mode, which means that it automatically commits changes\n * after executing each statement. If auto-commit mode has been\n * disabled, the method <code>commit</code> must be called explicitly in\n * order to commit changes; otherwise, database changes will not be saved.\n * <P>\n * A new <code>Connection</code> object created using the JDBC 2.1 core API\n * has an initially empty type map associated with it. A user may enter a\n * custom mapping for a UDT in this type map.\n * When a UDT is retrieved from a data source with the\n * method <code>ResultSet.getObject</code>, the <code>getObject</code> method\n * will check the connection's type map to see if there is an entry for that\n * UDT.  If so, the <code>getObject</code> method will map the UDT to the\n * class indicated.  If there is no entry, the UDT will be mapped using the\n * standard mapping.\n * <p>\n * A user may create a new type map, which is a <code>java.util.Map</code>\n * object, make an entry in it, and pass it to the <code>java.sql</code>\n * methods that can perform custom mapping.  In this case, the method\n * will use the given type map instead of the one associated with\n * the connection.\n * <p>\n * For example, the following code fragment specifies that the SQL\n * type <code>ATHLETES</code> will be mapped to the class\n * <code>Athletes</code> in the Java programming language.\n * The code fragment retrieves the type map for the <code>Connection\n * </code> object <code>con</code>, inserts the entry into it, and then sets\n * the type map with the new entry as the connection's type map.\n * <pre>\n *      java.util.Map map = con.getTypeMap();\n *      map.put(\"mySchemaName.ATHLETES\", Class.forName(\"Athletes\"));\n *      con.setTypeMap(map);\n * </pre>\n *\n * @see DriverManager#getConnection\n * @see Statement\n * @see ResultSet\n * @see DatabaseMetaData\n * @since 1.1\n */\npublic interface Connection  extends Wrapper, AutoCloseable {\n\n    /**\n     * Creates a <code>Statement</code> object for sending\n     * SQL statements to the database.\n     * SQL statements without parameters are normally\n     * executed using <code>Statement</code> objects. If the same SQL statement\n     * is executed many times, it may be more efficient to use a\n     * <code>PreparedStatement</code> object.\n     * <P>\n     * Result sets created using the returned <code>Statement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @return a new default <code>Statement</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    Statement createStatement() throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object for sending\n     * parameterized SQL statements to the database.\n     * <P>\n     * A SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     *\n     * <P><B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain <code>SQLException</code> objects.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     * parameter placeholders\n     * @return a new default <code>PreparedStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    PreparedStatement prepareStatement(String sql)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object for calling\n     * database stored procedures.\n     * The <code>CallableStatement</code> object provides\n     * methods for setting up its IN and OUT parameters, and\n     * methods for executing the call to a stored procedure.\n     *\n     * <P><B>Note:</B> This method is optimized for handling stored\n     * procedure call statements. Some drivers may send the call\n     * statement to the database when the method <code>prepareCall</code>\n     * is done; others\n     * may wait until the <code>CallableStatement</code> object\n     * is executed. This has no\n     * direct effect on users; however, it does affect which method\n     * throws certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>CallableStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders. Typically this statement is specified using JDBC\n     * call escape syntax.\n     * @return a new default <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    CallableStatement prepareCall(String sql) throws SQLException;\n\n    /**\n     * Converts the given SQL statement into the system's native SQL grammar.\n     * A driver may convert the JDBC SQL grammar into its system's\n     * native SQL grammar prior to sending it. This method returns the\n     * native form of the statement that the driver would have sent.\n     *\n     * @param sql an SQL statement that may contain one or more '?'\n     * parameter placeholders\n     * @return the native form of this statement\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    String nativeSQL(String sql) throws SQLException;\n\n    /**\n     * Sets this connection's auto-commit mode to the given state.\n     * If a connection is in auto-commit mode, then all its SQL\n     * statements will be executed and committed as individual\n     * transactions.  Otherwise, its SQL statements are grouped into\n     * transactions that are terminated by a call to either\n     * the method <code>commit</code> or the method <code>rollback</code>.\n     * By default, new connections are in auto-commit\n     * mode.\n     * <P>\n     * The commit occurs when the statement completes. The time when the statement\n     * completes depends on the type of SQL Statement:\n     * <ul>\n     * <li>For DML statements, such as Insert, Update or Delete, and DDL statements,\n     * the statement is complete as soon as it has finished executing.\n     * <li>For Select statements, the statement is complete when the associated result\n     * set is closed.\n     * <li>For <code>CallableStatement</code> objects or for statements that return\n     * multiple results, the statement is complete\n     * when all of the associated result sets have been closed, and all update\n     * counts and output parameters have been retrieved.\n     *</ul>\n     * <P>\n     * <B>NOTE:</B>  If this method is called during a transaction and the\n     * auto-commit mode is changed, the transaction is committed.  If\n     * <code>setAutoCommit</code> is called and the auto-commit mode is\n     * not changed, the call is a no-op.\n     *\n     * @param autoCommit <code>true</code> to enable auto-commit mode;\n     *         <code>false</code> to disable it\n     * @exception SQLException if a database access error occurs,\n     *  setAutoCommit(true) is called while participating in a distributed transaction,\n     * or this method is called on a closed connection\n     * @see #getAutoCommit\n     */\n    void setAutoCommit(boolean autoCommit) throws SQLException;\n\n    /**\n     * Retrieves the current auto-commit mode for this <code>Connection</code>\n     * object.\n     *\n     * @return the current state of this <code>Connection</code> object's\n     *         auto-commit mode\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setAutoCommit\n     */\n    boolean getAutoCommit() throws SQLException;\n\n    /**\n     * Makes all changes made since the previous\n     * commit/rollback permanent and releases any database locks\n     * currently held by this <code>Connection</code> object.\n     * This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * if this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void commit() throws SQLException;\n\n    /**\n     * Undoes all changes made in the current transaction\n     * and releases any database locks currently held\n     * by this <code>Connection</code> object. This method should be\n     * used only when auto-commit mode has been disabled.\n     *\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection or this\n     *            <code>Connection</code> object is in auto-commit mode\n     * @see #setAutoCommit\n     */\n    void rollback() throws SQLException;\n\n    /**\n     * Releases this <code>Connection</code> object's database and JDBC resources\n     * immediately instead of waiting for them to be automatically released.\n     * <P>\n     * Calling the method <code>close</code> on a <code>Connection</code>\n     * object that is already closed is a no-op.\n     * <P>\n     * It is <b>strongly recommended</b> that an application explicitly\n     * commits or rolls back an active transaction prior to calling the\n     * <code>close</code> method.  If the <code>close</code> method is called\n     * and there is an active transaction, the results are implementation-defined.\n     *\n     * @exception SQLException if a database access error occurs\n     */\n    void close() throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code> object has been\n     * closed.  A connection is closed if the method <code>close</code>\n     * has been called on it or if certain fatal errors have occurred.\n     * This method is guaranteed to return <code>true</code> only when\n     * it is called after the method <code>Connection.close</code> has\n     * been called.\n     * <P>\n     * This method generally cannot be called to determine whether a\n     * connection to a database is valid or invalid.  A typical client\n     * can determine that a connection is invalid by catching any\n     * exceptions that might be thrown when an operation is attempted.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is closed; <code>false</code> if it is still open\n     * @exception SQLException if a database access error occurs\n     */\n    boolean isClosed() throws SQLException;\n\n    //======================================================================\n    // Advanced features:\n\n    /**\n     * Retrieves a <code>DatabaseMetaData</code> object that contains\n     * metadata about the database to which this\n     * <code>Connection</code> object represents a connection.\n     * The metadata includes information about the database's\n     * tables, its supported SQL grammar, its stored\n     * procedures, the capabilities of this connection, and so on.\n     *\n     * @return a <code>DatabaseMetaData</code> object for this\n     *         <code>Connection</code> object\n     * @exception  SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    DatabaseMetaData getMetaData() throws SQLException;\n\n    /**\n     * Puts this connection in read-only mode as a hint to the driver to enable\n     * database optimizations.\n     *\n     * <P><B>Note:</B> This method cannot be called during a transaction.\n     *\n     * @param readOnly <code>true</code> enables read-only mode;\n     *        <code>false</code> disables it\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or this\n     *            method is called during a transaction\n     */\n    void setReadOnly(boolean readOnly) throws SQLException;\n\n    /**\n     * Retrieves whether this <code>Connection</code>\n     * object is in read-only mode.\n     *\n     * @return <code>true</code> if this <code>Connection</code> object\n     *         is read-only; <code>false</code> otherwise\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    boolean isReadOnly() throws SQLException;\n\n    /**\n     * Sets the given catalog name in order to select\n     * a subspace of this <code>Connection</code> object's database\n     * in which to work.\n     * <P>\n     * If the driver does not support catalogs, it will\n     * silently ignore this request.\n     * <p>\n     * Calling {@code setCatalog} has no effect on previously created or prepared\n     * {@code Statement} objects. It is implementation defined whether a DBMS\n     * prepare operation takes place immediately when the {@code Connection}\n     * method {@code prepareStatement} or {@code prepareCall} is invoked.\n     * For maximum portability, {@code setCatalog} should be called before a\n     * {@code Statement} is created or prepared.\n     *\n     * @param catalog the name of a catalog (subspace in this\n     *        <code>Connection</code> object's database) in which to work\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #getCatalog\n     */\n    void setCatalog(String catalog) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current catalog name.\n     *\n     * @return the current catalog name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setCatalog\n     */\n    String getCatalog() throws SQLException;\n\n    /**\n     * A constant indicating that transactions are not supported.\n     */\n    int TRANSACTION_NONE             = 0;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads can occur.\n     * This level allows a row changed by one transaction to be read\n     * by another transaction before any changes in that row have been\n     * committed (a \"dirty read\").  If any of the changes are rolled back,\n     * the second transaction will have retrieved an invalid row.\n     */\n    int TRANSACTION_READ_UNCOMMITTED = 1;\n\n    /**\n     * A constant indicating that\n     * dirty reads are prevented; non-repeatable reads and phantom\n     * reads can occur.  This level only prohibits a transaction\n     * from reading a row with uncommitted changes in it.\n     */\n    int TRANSACTION_READ_COMMITTED   = 2;\n\n    /**\n     * A constant indicating that\n     * dirty reads and non-repeatable reads are prevented; phantom\n     * reads can occur.  This level prohibits a transaction from\n     * reading a row with uncommitted changes in it, and it also\n     * prohibits the situation where one transaction reads a row,\n     * a second transaction alters the row, and the first transaction\n     * rereads the row, getting different values the second time\n     * (a \"non-repeatable read\").\n     */\n    int TRANSACTION_REPEATABLE_READ  = 4;\n\n    /**\n     * A constant indicating that\n     * dirty reads, non-repeatable reads and phantom reads are prevented.\n     * This level includes the prohibitions in\n     * <code>TRANSACTION_REPEATABLE_READ</code> and further prohibits the\n     * situation where one transaction reads all rows that satisfy\n     * a <code>WHERE</code> condition, a second transaction inserts a row that\n     * satisfies that <code>WHERE</code> condition, and the first transaction\n     * rereads for the same condition, retrieving the additional\n     * \"phantom\" row in the second read.\n     */\n    int TRANSACTION_SERIALIZABLE     = 8;\n\n    /**\n     * Attempts to change the transaction isolation level for this\n     * <code>Connection</code> object to the one given.\n     * The constants defined in the interface <code>Connection</code>\n     * are the possible transaction isolation levels.\n     * <P>\n     * <B>Note:</B> If this method is called during a transaction, the result\n     * is implementation-defined.\n     *\n     * @param level one of the following <code>Connection</code> constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>, or\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>.\n     *        (Note that <code>Connection.TRANSACTION_NONE</code> cannot be used\n     *        because it specifies that transactions are not supported.)\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameter is not one of the <code>Connection</code>\n     *            constants\n     * @see DatabaseMetaData#supportsTransactionIsolationLevel\n     * @see #getTransactionIsolation\n     */\n    void setTransactionIsolation(int level) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current\n     * transaction isolation level.\n     *\n     * @return the current transaction isolation level, which will be one\n     *         of the following constants:\n     *        <code>Connection.TRANSACTION_READ_UNCOMMITTED</code>,\n     *        <code>Connection.TRANSACTION_READ_COMMITTED</code>,\n     *        <code>Connection.TRANSACTION_REPEATABLE_READ</code>,\n     *        <code>Connection.TRANSACTION_SERIALIZABLE</code>, or\n     *        <code>Connection.TRANSACTION_NONE</code>.\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setTransactionIsolation\n     */\n    int getTransactionIsolation() throws SQLException;\n\n    /**\n     * Retrieves the first warning reported by calls on this\n     * <code>Connection</code> object.  If there is more than one\n     * warning, subsequent warnings will be chained to the first one\n     * and can be retrieved by calling the method\n     * <code>SQLWarning.getNextWarning</code> on the warning\n     * that was retrieved previously.\n     * <P>\n     * This method may not be\n     * called on a closed connection; doing so will cause an\n     * <code>SQLException</code> to be thrown.\n     *\n     * <P><B>Note:</B> Subsequent warnings will be chained to this\n     * SQLWarning.\n     *\n     * @return the first <code>SQLWarning</code> object or <code>null</code>\n     *         if there are none\n     * @exception SQLException if a database access error occurs or\n     *            this method is called on a closed connection\n     * @see SQLWarning\n     */\n    SQLWarning getWarnings() throws SQLException;\n\n    /**\n     * Clears all warnings reported for this <code>Connection</code> object.\n     * After a call to this method, the method <code>getWarnings</code>\n     * returns <code>null</code> until a new warning is\n     * reported for this <code>Connection</code> object.\n     *\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     */\n    void clearWarnings() throws SQLException;\n\n\n    //--------------------------JDBC 2.0-----------------------------\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param resultSetType a result set type; one of\n     *        <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *        <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *        <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *        <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *        <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type and\n     *         concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     *\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new PreparedStatement object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type and concurrency to be overridden.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType a result set type; one of\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency a concurrency type; one of\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @return a new <code>CallableStatement</code> object containing the\n     * pre-compiled SQL statement that will produce <code>ResultSet</code>\n     * objects with the given type and concurrency\n     * @exception SQLException if a database access error occurs, this method\n     * is called on a closed connection\n     *         or the given parameters are not <code>ResultSet</code>\n     *         constants indicating type and concurrency\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type and result set concurrency.\n     * @since 1.2\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency) throws SQLException;\n\n    /**\n     * Retrieves the <code>Map</code> object associated with this\n     * <code>Connection</code> object.\n     * Unless the application has added an entry, the type map returned\n     * will be empty.\n     * <p>\n     * You must invoke <code>setTypeMap</code> after making changes to the\n     * <code>Map</code> object returned from\n     *  <code>getTypeMap</code> as a JDBC driver may create an internal\n     * copy of the <code>Map</code> object passed to <code>setTypeMap</code>:\n     *\n     * <pre>\n     *      Map&lt;String,Class&lt;?&gt;&gt; myMap = con.getTypeMap();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @return the <code>java.util.Map</code> object associated\n     *         with this <code>Connection</code> object\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #setTypeMap\n     */\n    java.util.Map<String,Class<?>> getTypeMap() throws SQLException;\n\n    /**\n     * Installs the given <code>TypeMap</code> object as the type map for\n     * this <code>Connection</code> object.  The type map will be used for the\n     * custom mapping of SQL structured types and distinct types.\n     * <p>\n     * You must set the values for the <code>TypeMap</code> prior to\n     * callng <code>setMap</code> as a JDBC driver may create an internal copy\n     * of the <code>TypeMap</code>:\n     *\n     * <pre>\n     *      Map myMap&lt;String,Class&lt;?&gt;&gt; = new HashMap&lt;String,Class&lt;?&gt;&gt;();\n     *      myMap.put(\"mySchemaName.ATHLETES\", Athletes.class);\n     *      con.setTypeMap(myMap);\n     * </pre>\n     * @param map the <code>java.util.Map</code> object to install\n     *        as the replacement for this <code>Connection</code>\n     *        object's default type map\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection or\n     *        the given parameter is not a <code>java.util.Map</code>\n     *        object\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.2\n     * @see #getTypeMap\n     */\n    void setTypeMap(java.util.Map<String,Class<?>> map) throws SQLException;\n\n    //--------------------------JDBC 3.0-----------------------------\n\n\n    /**\n     * Changes the default holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object to the given\n     * holdability.  The default holdability of <code>ResultSet</code> objects\n     * can be determined by invoking\n     * {@link DatabaseMetaData#getResultSetHoldability}.\n     *\n     * @param holdability a <code>ResultSet</code> holdability constant; one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access occurs, this method is called\n     * on a closed connection, or the given parameter\n     *         is not a <code>ResultSet</code> constant indicating holdability\n     * @exception SQLFeatureNotSupportedException if the given holdability is not supported\n     * @see #getHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    void setHoldability(int holdability) throws SQLException;\n\n    /**\n     * Retrieves the current holdability of <code>ResultSet</code> objects\n     * created using this <code>Connection</code> object.\n     *\n     * @return the holdability, one of\n     *        <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *        <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @throws SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setHoldability\n     * @see DatabaseMetaData#getResultSetHoldability\n     * @see ResultSet\n     * @since 1.4\n     */\n    int getHoldability() throws SQLException;\n\n    /**\n     * Creates an unnamed savepoint in the current transaction and\n     * returns the new <code>Savepoint</code> object that represents it.\n     *\n     *<p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint() throws SQLException;\n\n    /**\n     * Creates a savepoint with the given name in the current transaction\n     * and returns the new <code>Savepoint</code> object that represents it.\n     *\n     * <p> if setSavepoint is invoked outside of an active transaction, a transaction will be started at this newly created\n     *savepoint.\n     *\n     * @param name a <code>String</code> containing the name of the savepoint\n     * @return the new <code>Savepoint</code> object\n     * @exception SQLException if a database access error occurs,\n          * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @since 1.4\n     */\n    Savepoint setSavepoint(String name) throws SQLException;\n\n    /**\n     * Undoes all changes made after the given <code>Savepoint</code> object\n     * was set.\n     * <P>\n     * This method should be used only when auto-commit has been disabled.\n     *\n     * @param savepoint the <code>Savepoint</code> object to roll back to\n     * @exception SQLException if a database access error occurs,\n     * this method is called while participating in a distributed transaction,\n     * this method is called on a closed connection,\n     *            the <code>Savepoint</code> object is no longer valid,\n     *            or this <code>Connection</code> object is currently in\n     *            auto-commit mode\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see Savepoint\n     * @see #rollback\n     * @since 1.4\n     */\n    void rollback(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Removes the specified <code>Savepoint</code>  and subsequent <code>Savepoint</code> objects from the current\n     * transaction. Any reference to the savepoint after it have been removed\n     * will cause an <code>SQLException</code> to be thrown.\n     *\n     * @param savepoint the <code>Savepoint</code> object to be removed\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection or\n     *            the given <code>Savepoint</code> object is not a valid\n     *            savepoint in the current transaction\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @since 1.4\n     */\n    void releaseSavepoint(Savepoint savepoint) throws SQLException;\n\n    /**\n     * Creates a <code>Statement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * This method is the same as the <code>createStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>Statement</code> object that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    Statement createStatement(int resultSetType, int resultSetConcurrency,\n                              int resultSetHoldability) throws SQLException;\n\n    /**\n     * Creates a <code>PreparedStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type, concurrency,\n     * and holdability.\n     * <P>\n     * This method is the same as the <code>prepareStatement</code> method\n     * above, but it allows the default result set\n     * type, concurrency, and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain one or more '?' IN\n     *            parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int resultSetType,\n                                       int resultSetConcurrency, int resultSetHoldability)\n        throws SQLException;\n\n    /**\n     * Creates a <code>CallableStatement</code> object that will generate\n     * <code>ResultSet</code> objects with the given type and concurrency.\n     * This method is the same as the <code>prepareCall</code> method\n     * above, but it allows the default result set\n     * type, result set concurrency type and holdability to be overridden.\n     *\n     * @param sql a <code>String</code> object that is the SQL statement to\n     *            be sent to the database; may contain on or more '?' parameters\n     * @param resultSetType one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.TYPE_FORWARD_ONLY</code>,\n     *         <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or\n     *         <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>\n     * @param resultSetConcurrency one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.CONCUR_READ_ONLY</code> or\n     *         <code>ResultSet.CONCUR_UPDATABLE</code>\n     * @param resultSetHoldability one of the following <code>ResultSet</code>\n     *        constants:\n     *         <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or\n     *         <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>\n     * @return a new <code>CallableStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will generate\n     *         <code>ResultSet</code> objects with the given type,\n     *         concurrency, and holdability\n     * @exception SQLException if a database access error occurs, this\n     * method is called on a closed connection\n     *            or the given parameters are not <code>ResultSet</code>\n     *            constants indicating type, concurrency, and holdability\n      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method or this method is not supported for the specified result\n     * set type, result set holdability and result set concurrency.\n     * @see ResultSet\n     * @since 1.4\n     */\n    CallableStatement prepareCall(String sql, int resultSetType,\n                                  int resultSetConcurrency,\n                                  int resultSetHoldability) throws SQLException;\n\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object that has\n     * the capability to retrieve auto-generated keys. The given constant\n     * tells the driver whether it should make auto-generated keys\n     * available for retrieval.  This parameter is ignored if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param autoGeneratedKeys a flag indicating whether auto-generated keys\n     *        should be returned; one of\n     *        <code>Statement.RETURN_GENERATED_KEYS</code> or\n     *        <code>Statement.NO_GENERATED_KEYS</code>\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled SQL statement, that will have the capability of\n     *         returning auto-generated keys\n     * @exception SQLException if a database access error occurs, this\n     *  method is called on a closed connection\n     *         or the given parameter is not a <code>Statement</code>\n     *         constant indicating whether auto-generated keys should be\n     *         returned\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method with a constant of Statement.RETURN_GENERATED_KEYS\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the indexes of the columns in the target\n     * table that contain the auto-generated keys that should be made\n     * available.  The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     *<p>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnIndexes an array of column indexes indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         indexes\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, int columnIndexes[])\n        throws SQLException;\n\n    /**\n     * Creates a default <code>PreparedStatement</code> object capable\n     * of returning the auto-generated keys designated by the given array.\n     * This array contains the names of the columns in the target\n     * table that contain the auto-generated keys that should be returned.\n     * The driver will ignore the array if the SQL statement\n     * is not an <code>INSERT</code> statement, or an SQL statement able to return\n     * auto-generated keys (the list of such statements is vendor-specific).\n     * <P>\n     * An SQL statement with or without IN parameters can be\n     * pre-compiled and stored in a <code>PreparedStatement</code> object. This\n     * object can then be used to efficiently execute this statement\n     * multiple times.\n     * <P>\n     * <B>Note:</B> This method is optimized for handling\n     * parametric SQL statements that benefit from precompilation. If\n     * the driver supports precompilation,\n     * the method <code>prepareStatement</code> will send\n     * the statement to the database for precompilation. Some drivers\n     * may not support precompilation. In this case, the statement may\n     * not be sent to the database until the <code>PreparedStatement</code>\n     * object is executed.  This has no direct effect on users; however, it does\n     * affect which methods throw certain SQLExceptions.\n     * <P>\n     * Result sets created using the returned <code>PreparedStatement</code>\n     * object will by default be type <code>TYPE_FORWARD_ONLY</code>\n     * and have a concurrency level of <code>CONCUR_READ_ONLY</code>.\n     * The holdability of the created result sets can be determined by\n     * calling {@link #getHoldability}.\n     *\n     * @param sql an SQL statement that may contain one or more '?' IN\n     *        parameter placeholders\n     * @param columnNames an array of column names indicating the columns\n     *        that should be returned from the inserted row or rows\n     * @return a new <code>PreparedStatement</code> object, containing the\n     *         pre-compiled statement, that is capable of returning the\n     *         auto-generated keys designated by the given array of column\n     *         names\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     *\n     * @since 1.4\n     */\n    PreparedStatement prepareStatement(String sql, String columnNames[])\n        throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Clob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of\n     * the <code>Clob</code> interface may be used to add data to the <code>Clob</code>.\n     * @return An object that implements the <code>Clob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Clob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Clob createClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>Blob</code> interface. The object\n     * returned initially contains no data.  The <code>setBinaryStream</code> and\n     * <code>setBytes</code> methods of the <code>Blob</code> interface may be used to add data to\n     * the <code>Blob</code>.\n     * @return  An object that implements the <code>Blob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>Blob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    Blob createBlob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>NClob</code> interface. The object\n     * returned initially contains no data.  The <code>setAsciiStream</code>,\n     * <code>setCharacterStream</code> and <code>setString</code> methods of the <code>NClob</code> interface may\n     * be used to add data to the <code>NClob</code>.\n     * @return An object that implements the <code>NClob</code> interface\n     * @throws SQLException if an object that implements the\n     * <code>NClob</code> interface can not be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     *\n     * @since 1.6\n     */\n    NClob createNClob() throws SQLException;\n\n    /**\n     * Constructs an object that implements the <code>SQLXML</code> interface. The object\n     * returned initially contains no data. The <code>createXmlStreamWriter</code> object and\n     * <code>setString</code> method of the <code>SQLXML</code> interface may be used to add data to the <code>SQLXML</code>\n     * object.\n     * @return An object that implements the <code>SQLXML</code> interface\n     * @throws SQLException if an object that implements the <code>SQLXML</code> interface can not\n     * be constructed, this method is\n     * called on a closed connection or a database access error occurs.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this data type\n     * @since 1.6\n     */\n    SQLXML createSQLXML() throws SQLException;\n\n        /**\n         * Returns true if the connection has not been closed and is still valid.\n         * The driver shall submit a query on the connection or use some other\n         * mechanism that positively verifies the connection is still valid when\n         * this method is called.\n         * <p>\n         * The query submitted by the driver to validate the connection shall be\n         * executed in the context of the current transaction.\n         *\n         * @param timeout -             The time in seconds to wait for the database operation\n         *                                              used to validate the connection to complete.  If\n         *                                              the timeout period expires before the operation\n         *                                              completes, this method returns false.  A value of\n         *                                              0 indicates a timeout is not applied to the\n         *                                              database operation.\n         *\n         * @return true if the connection is valid, false otherwise\n         * @exception SQLException if the value supplied for <code>timeout</code>\n         * is less than 0\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         boolean isValid(int timeout) throws SQLException;\n\n        /**\n         * Sets the value of the client info property specified by name to the\n         * value specified by value.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver\n         * and the maximum length that may be specified for each property.\n         * <p>\n         * The driver stores the value specified in a suitable location in the\n         * database.  For example in a special register, session parameter, or\n         * system table column.  For efficiency the driver may defer setting the\n         * value in the database until the next time a statement is executed or\n         * prepared.  Other than storing the client information in the appropriate\n         * place in the database, these methods shall not alter the behavior of\n         * the connection in anyway.  The values supplied to these methods are\n         * used for accounting, diagnostics and debugging purposes only.\n         * <p>\n         * The driver shall generate a warning if the client info name specified\n         * is not recognized by the driver.\n         * <p>\n         * If the value specified to this method is greater than the maximum\n         * length for the property the driver may either truncate the value and\n         * generate a warning or generate a <code>SQLClientInfoException</code>.  If the driver\n         * generates a <code>SQLClientInfoException</code>, the value specified was not set on the\n         * connection.\n         * <p>\n         * The following are standard client info properties.  Drivers are not\n         * required to support these properties however if the driver supports a\n         * client info property that can be described by one of the standard\n         * properties, the standard property name should be used.\n         *\n         * <ul>\n         * <li>ApplicationName  -       The name of the application currently utilizing\n         *                                                      the connection</li>\n         * <li>ClientUser               -       The name of the user that the application using\n         *                                                      the connection is performing work for.  This may\n         *                                                      not be the same as the user name that was used\n         *                                                      in establishing the connection.</li>\n         * <li>ClientHostname   -       The hostname of the computer the application\n         *                                                      using the connection is running on.</li>\n         * </ul>\n         *\n         * @param name          The name of the client info property to set\n         * @param value         The value to set the client info property to.  If the\n         *                                      value is null, the current value of the specified\n         *                                      property is cleared.\n         *\n         * @throws      SQLClientInfoException if the database server returns an error while\n         *                      setting the client info value on the database server or this method\n         * is called on a closed connection\n         *\n         * @since 1.6\n         */\n         void setClientInfo(String name, String value)\n                throws SQLClientInfoException;\n\n        /**\n     * Sets the value of the connection's client info properties.  The\n     * <code>Properties</code> object contains the names and values of the client info\n     * properties to be set.  The set of client info properties contained in\n     * the properties list replaces the current set of client info properties\n     * on the connection.  If a property that is currently set on the\n     * connection is not present in the properties list, that property is\n     * cleared.  Specifying an empty properties list will clear all of the\n     * properties on the connection.  See <code>setClientInfo (String, String)</code> for\n     * more information.\n     * <p>\n     * If an error occurs in setting any of the client info properties, a\n     * <code>SQLClientInfoException</code> is thrown. The <code>SQLClientInfoException</code>\n     * contains information indicating which client info properties were not set.\n     * The state of the client information is unknown because\n     * some databases do not allow multiple client info properties to be set\n     * atomically.  For those databases, one or more properties may have been\n     * set before the error occurred.\n     *\n     *\n     * @param properties                the list of client info properties to set\n     *\n     * @see java.sql.Connection#setClientInfo(String, String) setClientInfo(String, String)\n     * @since 1.6\n     *\n     * @throws SQLClientInfoException if the database server returns an error while\n     *                  setting the clientInfo values on the database server or this method\n     * is called on a closed connection\n     *\n     */\n         void setClientInfo(Properties properties)\n                throws SQLClientInfoException;\n\n        /**\n         * Returns the value of the client info property specified by name.  This\n         * method may return null if the specified client info property has not\n         * been set and does not have a default value.  This method will also\n         * return null if the specified client info property name is not supported\n         * by the driver.\n         * <p>\n         * Applications may use the <code>DatabaseMetaData.getClientInfoProperties</code>\n         * method to determine the client info properties supported by the driver.\n         *\n         * @param name          The name of the client info property to retrieve\n         *\n         * @return                      The value of the client info property specified\n         *\n         * @throws SQLException         if the database server returns an error when\n         *                              fetching the client info value from the database\n         *                              or this method is called on a closed connection\n         *\n         * @since 1.6\n         *\n         * @see java.sql.DatabaseMetaData#getClientInfoProperties\n         */\n         String getClientInfo(String name)\n                throws SQLException;\n\n        /**\n         * Returns a list containing the name and current value of each client info\n         * property supported by the driver.  The value of a client info property\n         * may be null if the property has not been set and does not have a\n         * default value.\n         *\n         * @return      A <code>Properties</code> object that contains the name and current value of\n         *                      each of the client info properties supported by the driver.\n         *\n         * @throws      SQLException if the database server returns an error when\n         *                      fetching the client info values from the database\n         * or this method is called on a closed connection\n         *\n         * @since 1.6\n         */\n         Properties getClientInfo()\n                throws SQLException;\n\n/**\n  * Factory method for creating Array objects.\n  *<p>\n  * <b>Note: </b>When <code>createArrayOf</code> is used to create an array object\n  * that maps to a primitive data type, then it is implementation-defined\n  * whether the <code>Array</code> object is an array of that primitive\n  * data type or an array of <code>Object</code>.\n  * <p>\n  * <b>Note: </b>The JDBC driver is responsible for mapping the elements\n  * <code>Object</code> array to the default JDBC SQL type defined in\n  * java.sql.Types for the given class of <code>Object</code>. The default\n  * mapping is specified in Appendix B of the JDBC specification.  If the\n  * resulting JDBC type is not the appropriate type for the given typeName then\n  * it is implementation defined whether an <code>SQLException</code> is\n  * thrown or the driver supports the resulting conversion.\n  *\n  * @param typeName the SQL name of the type the elements of the array map to. The typeName is a\n  * database-specific name which may be the name of a built-in type, a user-defined type or a standard  SQL type supported by this database. This\n  *  is the value returned by <code>Array.getBaseTypeName</code>\n  * @param elements the elements that populate the returned object\n  * @return an Array object whose elements map to the specified SQL type\n  * @throws SQLException if a database error occurs, the JDBC type is not\n  *  appropriate for the typeName and the conversion is not supported, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Array createArrayOf(String typeName, Object[] elements) throws\nSQLException;\n\n/**\n  * Factory method for creating Struct objects.\n  *\n  * @param typeName the SQL type name of the SQL structured type that this <code>Struct</code>\n  * object maps to. The typeName is the name of  a user-defined type that\n  * has been defined for this database. It is the value returned by\n  * <code>Struct.getSQLTypeName</code>.\n\n  * @param attributes the attributes that populate the returned object\n  * @return a Struct object that maps to the given SQL type and is populated with the given attributes\n  * @throws SQLException if a database error occurs, the typeName is null or this method is called on a closed connection\n  * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this data type\n  * @since 1.6\n  */\n Struct createStruct(String typeName, Object[] attributes)\nthrows SQLException;\n\n   //--------------------------JDBC 4.1 -----------------------------\n\n   /**\n    * Sets the given schema name to access.\n    * <P>\n    * If the driver does not support schemas, it will\n    * silently ignore this request.\n    * <p>\n    * Calling {@code setSchema} has no effect on previously created or prepared\n    * {@code Statement} objects. It is implementation defined whether a DBMS\n    * prepare operation takes place immediately when the {@code Connection}\n    * method {@code prepareStatement} or {@code prepareCall} is invoked.\n    * For maximum portability, {@code setSchema} should be called before a\n    * {@code Statement} is created or prepared.\n    *\n    * @param schema the name of a schema  in which to work\n    * @exception SQLException if a database access error occurs\n    * or this method is called on a closed connection\n    * @see #getSchema\n    * @since 1.7\n    */\n    void setSchema(String schema) throws SQLException;\n\n    /**\n     * Retrieves this <code>Connection</code> object's current schema name.\n     *\n     * @return the current schema name or <code>null</code> if there is none\n     * @exception SQLException if a database access error occurs\n     * or this method is called on a closed connection\n     * @see #setSchema\n     * @since 1.7\n     */\n    String getSchema() throws SQLException;\n\n    /**\n     * Terminates an open connection.  Calling <code>abort</code> results in:\n     * <ul>\n     * <li>The connection marked as closed\n     * <li>Closes any physical connection to the database\n     * <li>Releases resources used by the connection\n     * <li>Insures that any thread that is currently accessing the connection\n     * will either progress to completion or throw an <code>SQLException</code>.\n     * </ul>\n     * <p>\n     * Calling <code>abort</code> marks the connection closed and releases any\n     * resources. Calling <code>abort</code> on a closed connection is a\n     * no-op.\n     * <p>\n     * It is possible that the aborting and releasing of the resources that are\n     * held by the connection can take an extended period of time.  When the\n     * <code>abort</code> method returns, the connection will have been marked as\n     * closed and the <code>Executor</code> that was passed as a parameter to abort\n     * may still be executing tasks to release resources.\n     * <p>\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling <code>abort</code>,\n     * this method throws a\n     * <code>java.lang.SecurityException</code>.\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>abort</code>.\n     * @throws java.sql.SQLException if a database access error occurs or\n     * the {@code executor} is {@code null},\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling <code>abort</code>\n     * @see SecurityManager#checkPermission\n     * @see Executor\n     * @since 1.7\n     */\n    void abort(Executor executor) throws SQLException;\n\n    /**\n     *\n     * Sets the maximum period a <code>Connection</code> or\n     * objects created from the <code>Connection</code>\n     * will wait for the database to reply to any one request. If any\n     *  request remains unanswered, the waiting method will\n     * return with a <code>SQLException</code>, and the <code>Connection</code>\n     * or objects created from the <code>Connection</code>  will be marked as\n     * closed. Any subsequent use of\n     * the objects, with the exception of the <code>close</code>,\n     * <code>isClosed</code> or <code>Connection.isValid</code>\n     * methods, will result in  a <code>SQLException</code>.\n     * <p>\n     * <b>Note</b>: This method is intended to address a rare but serious\n     * condition where network partitions can cause threads issuing JDBC calls\n     * to hang uninterruptedly in socket reads, until the OS TCP-TIMEOUT\n     * (typically 10 minutes). This method is related to the\n     * {@link #abort abort() } method which provides an administrator\n     * thread a means to free any such threads in cases where the\n     * JDBC connection is accessible to the administrator thread.\n     * The <code>setNetworkTimeout</code> method will cover cases where\n     * there is no administrator thread, or it has no access to the\n     * connection. This method is severe in it's effects, and should be\n     * given a high enough value so it is never triggered before any more\n     * normal timeouts, such as transaction timeouts.\n     * <p>\n     * JDBC driver implementations  may also choose to support the\n     * {@code setNetworkTimeout} method to impose a limit on database\n     * response time, in environments where no network is present.\n     * <p>\n     * Drivers may internally implement some or all of their API calls with\n     * multiple internal driver-database transmissions, and it is left to the\n     * driver implementation to determine whether the limit will be\n     * applied always to the response to the API call, or to any\n     * single  request made during the API call.\n     * <p>\n     *\n     * This method can be invoked more than once, such as to set a limit for an\n     * area of JDBC code, and to reset to the default on exit from this area.\n     * Invocation of this method has no impact on already outstanding\n     * requests.\n     * <p>\n     * The {@code Statement.setQueryTimeout()} timeout value is independent of the\n     * timeout value specified in {@code setNetworkTimeout}. If the query timeout\n     * expires  before the network timeout then the\n     * statement execution will be canceled. If the network is still\n     * active the result will be that both the statement and connection\n     * are still usable. However if the network timeout expires before\n     * the query timeout or if the statement timeout fails due to network\n     * problems, the connection will be marked as closed, any resources held by\n     * the connection will be released and both the connection and\n     * statement will be unusable.\n     * <p>\n     * When the driver determines that the {@code setNetworkTimeout} timeout\n     * value has expired, the JDBC driver marks the connection\n     * closed and releases any resources held by the connection.\n     * <p>\n     *\n     * This method checks to see that there is an <code>SQLPermission</code>\n     * object before allowing the method to proceed.  If a\n     * <code>SecurityManager</code> exists and its\n     * <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>, this method throws a\n     * <code>java.lang.SecurityException</code>.\n     *\n     * @param executor  The <code>Executor</code>  implementation which will\n     * be used by <code>setNetworkTimeout</code>.\n     * @param milliseconds The time in milliseconds to wait for the database\n     * operation\n     *  to complete.  If the JDBC driver does not support milliseconds, the\n     * JDBC driver will round the value up to the nearest second.  If the\n     * timeout period expires before the operation\n     * completes, a SQLException will be thrown.\n     * A value of 0 indicates that there is not timeout for database operations.\n     * @throws java.sql.SQLException if a database access error occurs, this\n     * method is called on a closed connection,\n     * the {@code executor} is {@code null},\n     * or the value specified for <code>seconds</code> is less than 0.\n     * @throws java.lang.SecurityException if a security manager exists and its\n     *    <code>checkPermission</code> method denies calling\n     * <code>setNetworkTimeout</code>.\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see SecurityManager#checkPermission\n     * @see Statement#setQueryTimeout\n     * @see #getNetworkTimeout\n     * @see #abort\n     * @see Executor\n     * @since 1.7\n     */\n    void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException;\n\n\n    /**\n     * Retrieves the number of milliseconds the driver will\n     * wait for a database request to complete.\n     * If the limit is exceeded, a\n     * <code>SQLException</code> is thrown.\n     *\n     * @return the current timeout limit in milliseconds; zero means there is\n     *         no limit\n     * @throws SQLException if a database access error occurs or\n     * this method is called on a closed <code>Connection</code>\n     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support\n     * this method\n     * @see #setNetworkTimeout\n     * @since 1.7\n     */\n    int getNetworkTimeout() throws SQLException;\n\n    // JDBC 4.3\n\n     /**\n     * Hints to the driver that a request, an independent unit of work, is beginning\n     * on this connection. Each request is independent of all other requests\n     * with regard to state local to the connection either on the client or the\n     * server. Work done between {@code beginRequest}, {@code endRequest}\n     * pairs does not depend on any other work done on the connection either as\n     * part of another request or outside of any request. A request may include multiple\n     * transactions. There may be dependencies on committed database state as\n     * that is not local to the connection.\n     * <p>\n     * Local state is defined as any state associated with a Connection that is\n     * local to the current Connection either in the client or the database that\n     * is not transparently reproducible.\n     * <p>\n     * Calls to {@code beginRequest} and {@code endRequest}  are not nested.\n     * Multiple calls to {@code beginRequest} without an intervening call\n     * to {@code endRequest} is not an error. The first {@code beginRequest} call\n     * marks the start of the request and subsequent calls are treated as\n     * a no-op\n     * <p>\n     * Use of {@code beginRequest} and {@code endRequest} is optional, vendor\n     * specific and should largely be transparent. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code beginRequest} is called.\n     * Using these methods may improve performance or provide other benefits.\n     * Consult your vendors documentation for additional information.\n     * <p>\n     * It is recommended to\n     * enclose each unit of work in {@code beginRequest}, {@code endRequest}\n     * pairs such that there is no open transaction at the beginning or end of\n     * the request and no dependency on local state that crosses request\n     * boundaries. Committed database state is not local.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     *\n     * @apiNote\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code beginRequest} on the underlying connection\n     * prior to returning a connection to the caller.\n     * <p>\n     * The pooling manager does not need to call {@code beginRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see endRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void beginRequest() throws SQLException {\n       // Default method takes no action\n    }\n\n    /**\n     * Hints to the driver that a request, an independent unit of work,\n     * has completed. Calls to {@code beginRequest}\n     * and {@code endRequest} are not nested. Multiple\n     * calls to {@code endRequest} without an intervening call to {@code beginRequest}\n     * is not an error. The first {@code endRequest} call\n     * marks the request completed and subsequent calls are treated as\n     * a no-op. If {@code endRequest} is called without an initial call to\n     * {@code beginRequest} is a no-op.\n     *<p>\n     * The exact behavior of this method is vendor specific. In particular\n     * implementations may detect conditions that indicate dependence on\n     * other work such as an open transaction. It is recommended though not\n     * required that implementations throw a {@code SQLException} if there is an active\n     * transaction and {@code endRequest} is called.\n     *\n     * @implSpec\n     * The default implementation is a no-op.\n     * @apiNote\n     *\n     * This method is to be used by Connection pooling managers.\n     * <p>\n     * The pooling manager should call {@code endRequest} on the underlying connection\n     * when the applications returns the connection back to the connection pool.\n     * <p>\n     * The pooling manager does not need to call {@code endRequest} if:\n     * <ul>\n     * <li>The connection pool caches {@code PooledConnection} objects</li>\n     * <li>Returns a logical connection handle when {@code getConnection} is\n     * called by the application</li>\n     * <li>The logical {@code Connection} is closed by calling\n     * {@code Connection.close} prior to returning the {@code PooledConnection}\n     * to the cache.</li>\n     * </ul>\n     * @throws SQLException if an error occurs\n     * @since 9\n     * @see beginRequest\n     * @see javax.sql.PooledConnection\n     */\n    default void endRequest() throws SQLException {\n            // Default method takes no action\n    }\n\n    /**\n     * Sets and validates the sharding keys for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     *\n     * @apiNote\n     * This method validates that the sharding keys are valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param superShardingKey the super sharding key to be validated against this\n     * connection. The super sharding key may be {@code null}.\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed, otherwise the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding keys are valid\n     * and set on this connection; false if the sharding keys are not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if an error occurs while performing this validation;\n     * a {@code superSharedingKey} is specified\n     * without a {@code shardingKey};\n     * this method is called on a closed {@code connection}; or\n     * the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey,\n            ShardingKey superShardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Sets and validates the sharding key for this connection. A {@code null}\n     * value may be specified for the sharding Key. The validity\n     * of a {@code null} sharding key is vendor-specific. Consult your vendor&#39;s\n     * documentation for additional information.\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method validates  that the sharding key is valid for the\n     * {@code Connection}. The timeout value indicates how long the driver\n     * should wait for the {@code Connection} to verify that the sharding key\n     * is valid before {@code setShardingKeyIfValid} returns false.\n     * @param shardingKey the sharding key to be validated against this connection.\n     * The sharding key may be {@code null}\n     * @param timeout time in seconds before which the validation process is expected to\n     * be completed,else the validation process is aborted. A value of 0 indicates\n     * the validation process will not time out.\n     * @return true if the connection is valid and the sharding key is valid to be\n     * set on this connection; false if the sharding key is not valid or\n     * the timeout period expires before the operation completes.\n     * @throws SQLException if there is an error while performing this validation;\n     * this method is called on a closed {@code connection};\n     * or the {@code timeout} value is negative.\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default boolean setShardingKeyIfValid(ShardingKey shardingKey, int timeout)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKeyIfValid not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey and superShardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding keys but does not require a\n     * round trip to the database to validate that the sharding keys are valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @param superShardingKey the super sharding key to set on this connection.\n     * The super sharding key may be {@code null}\n     * @throws SQLException if an error  occurs setting the sharding keys;\n     * this method is called on a closed {@code connection}; or\n     * a {@code superSharedingKey} is specified without a {@code shardingKey}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n\n    /**\n     * Specifies a shardingKey to use with this Connection\n     * @implSpec\n     * The default implementation will throw a\n     * {@code SQLFeatureNotSupportedException}.\n     * @apiNote\n     * This method sets the specified sharding key but does not require a\n     * round trip to the database to validate that the sharding key is valid\n     * for the {@code Connection}.\n     * @param shardingKey the sharding key to set on this connection. The sharding\n     * key may be {@code null}\n     * @throws SQLException if an error occurs setting the sharding key; or\n     * this method is called on a closed {@code connection}\n     * @throws SQLFeatureNotSupportedException if the driver does not support sharding\n     * @since 9\n     * @see ShardingKey\n     * @see ShardingKeyBuilder\n     */\n    default void setShardingKey(ShardingKey shardingKey)\n            throws SQLException {\n        throw new SQLFeatureNotSupportedException(\"setShardingKey not implemented\");\n    }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/.metals/readonly/dependencies/src.zip/java.sql/java/sql/Connection.java"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":51,"character":71}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":168})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":51,"character":72}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":169})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":51,"character":72}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol resultSet[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":52,"character":47}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":171})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":52,"character":47}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //     print(resultSet.getString(1) + " " + resultSet.getString(2) + " " + resultSet.getString(3))[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":172})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":51,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     // while ( resultSet.next() ) {[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":173})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":49,"character":40}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":174})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":48,"character":38}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     quer = quer.getString[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":175})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":48,"character":38}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     quer = quer.getString[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol next[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol getString[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":48}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol task[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":69}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol Exit[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":12,"character":68}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("Pleaes Choose an option using number keys 1 - 4: ")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol 4[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":180})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":44}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol n3[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol task[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":48,"character":43}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":182})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":49,"character":47}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     //val resultSet = statement.executeQuery("SELECT * FROM orders") // Change query to your table[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol statement[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":49,"character":42}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":184})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":49,"character":39}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     statement.executeUpdate("INSERT INTO project0 (todo) Values ("+quer+")")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol executeUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":57}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol List[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":54}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol List[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":13,"character":54}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:             println("1: Add task\n2: Remove task\n3: List tasks\n4: Exit")[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol List[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":39,"character":50}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val url = "jdbc:mysql://localhost:3306/project"[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":189})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":39,"character":49}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val url = "jdbc:mysql://localhost:3306/project"[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/cancelRequest: JsonRpcNotificationMessage(2.0, $/cancelRequest, {"id":190})[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition json request: {"textDocument":{"uri":"file:///c%3A/Users/Family/Desktop/Revature%20-%20Big%20Data/VS%20Code/Project0/src/main/scala/Project0.scala"},"position":{"line":40,"character":39}}[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition found line:                     val username = "root"[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol root[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol localhost[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0msymbol localhost[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition potentials: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mlsp-definition locations Vector()[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨192, shutdown, null})[0m
